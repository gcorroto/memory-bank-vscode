"use strict";
/**
 * Kiuwan REST API
 * Kiuwan REST API specification
 *
 * OpenAPI spec version: 2.8.1910.6-SNAPSHOT
 * Contact: support@kiuwan.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const localVarRequest = require("request");
let defaultBasePath = 'https://api.kiuwan.com';
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
/* tslint:disable:no-unused-variable */
let primitives = [
    "string",
    "boolean",
    "double",
    "integer",
    "long",
    "float",
    "number",
    "any"
];
class ObjectSerializer {
    static findCorrectType(data, expectedType) {
        if (data == undefined) {
            return expectedType;
        }
        else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        }
        else if (expectedType === "Date") {
            return expectedType;
        }
        else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }
            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }
            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            }
            else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                }
                else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }
    static serialize(data, type) {
        if (data == undefined) {
            return data;
        }
        else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        }
        else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        }
        else if (type === "Date") {
            return data.toString();
        }
        else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }
            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }
    static deserialize(data, type) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        }
        else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        }
        else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        }
        else if (type === "Date") {
            return new Date(data);
        }
        else {
            if (enumsMap[type]) { // is Enum
                return data;
            }
            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}
class AccessControlConfigurationData {
    static getAttributeTypeMap() {
        return AccessControlConfigurationData.attributeTypeMap;
    }
}
AccessControlConfigurationData.discriminator = undefined;
AccessControlConfigurationData.attributeTypeMap = [
    {
        "name": "assignmentMode",
        "baseName": "assignmentMode",
        "type": "AccessControlConfigurationData.AssignmentModeEnum"
    },
    {
        "name": "overrideUserGroupConfig",
        "baseName": "overrideUserGroupConfig",
        "type": "boolean"
    },
    {
        "name": "managementFeatures",
        "baseName": "managementFeatures",
        "type": "Array<string>"
    },
    {
        "name": "portfolioRoles",
        "baseName": "portfolioRoles",
        "type": "Array<PortfolioRoleData>"
    },
    {
        "name": "applicationRoles",
        "baseName": "applicationRoles",
        "type": "Array<ApplicationRoleData>"
    },
    {
        "name": "businessValueRoles",
        "baseName": "businessValueRoles",
        "type": "Array<BusinessValuePortfolioRoleData>"
    },
    {
        "name": "providerRoles",
        "baseName": "providerRoles",
        "type": "Array<ProviderPortfolioRoleData>"
    }
];
exports.AccessControlConfigurationData = AccessControlConfigurationData;
(function (AccessControlConfigurationData) {
    let AssignmentModeEnum;
    (function (AssignmentModeEnum) {
        AssignmentModeEnum[AssignmentModeEnum["ADD"] = 'ADD'] = "ADD";
        AssignmentModeEnum[AssignmentModeEnum["DELETE"] = 'DELETE'] = "DELETE";
        AssignmentModeEnum[AssignmentModeEnum["OVERWRITE"] = 'OVERWRITE'] = "OVERWRITE";
    })(AssignmentModeEnum = AccessControlConfigurationData.AssignmentModeEnum || (AccessControlConfigurationData.AssignmentModeEnum = {}));
})(AccessControlConfigurationData = exports.AccessControlConfigurationData || (exports.AccessControlConfigurationData = {}));
class ActionPlanDefectsResponse {
    static getAttributeTypeMap() {
        return ActionPlanDefectsResponse.attributeTypeMap;
    }
}
ActionPlanDefectsResponse.discriminator = undefined;
ActionPlanDefectsResponse.attributeTypeMap = [
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "description",
        "baseName": "description",
        "type": "string"
    },
    {
        "name": "creation",
        "baseName": "creation",
        "type": "string"
    },
    {
        "name": "expiration",
        "baseName": "expiration",
        "type": "string"
    },
    {
        "name": "createdBy",
        "baseName": "createdBy",
        "type": "string"
    },
    {
        "name": "assignedTo",
        "baseName": "assignedTo",
        "type": "string"
    },
    {
        "name": "progress",
        "baseName": "progress",
        "type": "number"
    },
    {
        "name": "estimate",
        "baseName": "estimate",
        "type": "string"
    },
    {
        "name": "pendingEffort",
        "baseName": "pendingEffort",
        "type": "string"
    },
    {
        "name": "purged",
        "baseName": "purged",
        "type": "boolean"
    },
    {
        "name": "allDefects",
        "baseName": "allDefects",
        "type": "Array<DefectDetailResponse>"
    }
];
exports.ActionPlanDefectsResponse = ActionPlanDefectsResponse;
class ActionPlanDetailResponse {
    static getAttributeTypeMap() {
        return ActionPlanDetailResponse.attributeTypeMap;
    }
}
ActionPlanDetailResponse.discriminator = undefined;
ActionPlanDetailResponse.attributeTypeMap = [
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "description",
        "baseName": "description",
        "type": "string"
    },
    {
        "name": "creation",
        "baseName": "creation",
        "type": "string"
    },
    {
        "name": "expiration",
        "baseName": "expiration",
        "type": "string"
    },
    {
        "name": "createdBy",
        "baseName": "createdBy",
        "type": "string"
    },
    {
        "name": "assignedTo",
        "baseName": "assignedTo",
        "type": "string"
    },
    {
        "name": "progress",
        "baseName": "progress",
        "type": "number"
    },
    {
        "name": "estimate",
        "baseName": "estimate",
        "type": "string"
    },
    {
        "name": "pendingEffort",
        "baseName": "pendingEffort",
        "type": "string"
    },
    {
        "name": "purged",
        "baseName": "purged",
        "type": "boolean"
    }
];
exports.ActionPlanDetailResponse = ActionPlanDetailResponse;
class ActionPlanPendingDefectsResponse {
    static getAttributeTypeMap() {
        return ActionPlanPendingDefectsResponse.attributeTypeMap;
    }
}
ActionPlanPendingDefectsResponse.discriminator = undefined;
ActionPlanPendingDefectsResponse.attributeTypeMap = [
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "description",
        "baseName": "description",
        "type": "string"
    },
    {
        "name": "creation",
        "baseName": "creation",
        "type": "string"
    },
    {
        "name": "expiration",
        "baseName": "expiration",
        "type": "string"
    },
    {
        "name": "createdBy",
        "baseName": "createdBy",
        "type": "string"
    },
    {
        "name": "assignedTo",
        "baseName": "assignedTo",
        "type": "string"
    },
    {
        "name": "progress",
        "baseName": "progress",
        "type": "number"
    },
    {
        "name": "estimate",
        "baseName": "estimate",
        "type": "string"
    },
    {
        "name": "pendingEffort",
        "baseName": "pendingEffort",
        "type": "string"
    },
    {
        "name": "purged",
        "baseName": "purged",
        "type": "boolean"
    },
    {
        "name": "pendingDefects",
        "baseName": "pendingDefects",
        "type": "Array<DefectDetailResponse>"
    }
];
exports.ActionPlanPendingDefectsResponse = ActionPlanPendingDefectsResponse;
class ActionPlanProgressResponse {
    static getAttributeTypeMap() {
        return ActionPlanProgressResponse.attributeTypeMap;
    }
}
ActionPlanProgressResponse.discriminator = undefined;
ActionPlanProgressResponse.attributeTypeMap = [
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "description",
        "baseName": "description",
        "type": "string"
    },
    {
        "name": "creation",
        "baseName": "creation",
        "type": "string"
    },
    {
        "name": "expiration",
        "baseName": "expiration",
        "type": "string"
    },
    {
        "name": "createdBy",
        "baseName": "createdBy",
        "type": "string"
    },
    {
        "name": "assignedTo",
        "baseName": "assignedTo",
        "type": "string"
    },
    {
        "name": "progress",
        "baseName": "progress",
        "type": "number"
    },
    {
        "name": "estimate",
        "baseName": "estimate",
        "type": "string"
    },
    {
        "name": "pendingEffort",
        "baseName": "pendingEffort",
        "type": "string"
    },
    {
        "name": "purged",
        "baseName": "purged",
        "type": "boolean"
    },
    {
        "name": "riskIndexBefore",
        "baseName": "riskIndexBefore",
        "type": "number"
    },
    {
        "name": "globalIndicatorBefore",
        "baseName": "globalIndicatorBefore",
        "type": "number"
    },
    {
        "name": "effortToTargetBefore",
        "baseName": "effortToTargetBefore",
        "type": "number"
    },
    {
        "name": "qualityIndicatorsBefore",
        "baseName": "qualityIndicatorsBefore",
        "type": "{ [key: string]: number; }"
    },
    {
        "name": "riskIndexAfter",
        "baseName": "riskIndexAfter",
        "type": "number"
    },
    {
        "name": "globalIndicatorAfter",
        "baseName": "globalIndicatorAfter",
        "type": "number"
    },
    {
        "name": "effortToTargetAfter",
        "baseName": "effortToTargetAfter",
        "type": "number"
    },
    {
        "name": "qualityIndicatorsAfter",
        "baseName": "qualityIndicatorsAfter",
        "type": "{ [key: string]: number; }"
    },
    {
        "name": "metrics",
        "baseName": "metrics",
        "type": "{ [key: string]: number; }"
    }
];
exports.ActionPlanProgressResponse = ActionPlanProgressResponse;
class ActionPlanRemovedDefectsResponse {
    static getAttributeTypeMap() {
        return ActionPlanRemovedDefectsResponse.attributeTypeMap;
    }
}
ActionPlanRemovedDefectsResponse.discriminator = undefined;
ActionPlanRemovedDefectsResponse.attributeTypeMap = [
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "description",
        "baseName": "description",
        "type": "string"
    },
    {
        "name": "creation",
        "baseName": "creation",
        "type": "string"
    },
    {
        "name": "expiration",
        "baseName": "expiration",
        "type": "string"
    },
    {
        "name": "createdBy",
        "baseName": "createdBy",
        "type": "string"
    },
    {
        "name": "assignedTo",
        "baseName": "assignedTo",
        "type": "string"
    },
    {
        "name": "progress",
        "baseName": "progress",
        "type": "number"
    },
    {
        "name": "estimate",
        "baseName": "estimate",
        "type": "string"
    },
    {
        "name": "pendingEffort",
        "baseName": "pendingEffort",
        "type": "string"
    },
    {
        "name": "purged",
        "baseName": "purged",
        "type": "boolean"
    },
    {
        "name": "removedDefects",
        "baseName": "removedDefects",
        "type": "Array<DefectDetailResponse>"
    }
];
exports.ActionPlanRemovedDefectsResponse = ActionPlanRemovedDefectsResponse;
class AnalysisDefectsResponse {
    static getAttributeTypeMap() {
        return AnalysisDefectsResponse.attributeTypeMap;
    }
}
AnalysisDefectsResponse.discriminator = undefined;
AnalysisDefectsResponse.attributeTypeMap = [
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "description",
        "baseName": "description",
        "type": "string"
    },
    {
        "name": "auditName",
        "baseName": "auditName",
        "type": "string"
    },
    {
        "name": "applicationBusinessValue",
        "baseName": "applicationBusinessValue",
        "type": "AnalysisDefectsResponse.ApplicationBusinessValueEnum"
    },
    {
        "name": "applicationProvider",
        "baseName": "applicationProvider",
        "type": "string"
    },
    {
        "name": "applicationPortfolios",
        "baseName": "applicationPortfolios",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "label",
        "baseName": "label",
        "type": "string"
    },
    {
        "name": "date",
        "baseName": "date",
        "type": "string"
    },
    {
        "name": "modelId",
        "baseName": "modelId",
        "type": "number"
    },
    {
        "name": "encoding",
        "baseName": "encoding",
        "type": "string"
    },
    {
        "name": "analysisCode",
        "baseName": "analysisCode",
        "type": "string"
    },
    {
        "name": "analysisURL",
        "baseName": "analysisURL",
        "type": "string"
    },
    {
        "name": "auditResultURL",
        "baseName": "auditResultURL",
        "type": "string"
    },
    {
        "name": "analysisBusinessValue",
        "baseName": "analysisBusinessValue",
        "type": "AnalysisDefectsResponse.AnalysisBusinessValueEnum"
    },
    {
        "name": "analysisProvider",
        "baseName": "analysisProvider",
        "type": "string"
    },
    {
        "name": "analysisPortfolios",
        "baseName": "analysisPortfolios",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "analysisStatus",
        "baseName": "analysisStatus",
        "type": "AnalysisDefectsResponse.AnalysisStatusEnum"
    },
    {
        "name": "languages",
        "baseName": "languages",
        "type": "Array<MetricValueData>"
    },
    {
        "name": "architecture",
        "baseName": "architecture",
        "type": "MetadataArchitectureData"
    },
    {
        "name": "insightsData",
        "baseName": "insightsData",
        "type": "MetadataInsightsData"
    },
    {
        "name": "defectsCount",
        "baseName": "defects_count",
        "type": "number"
    },
    {
        "name": "activeDefectsCount",
        "baseName": "activeDefects_count",
        "type": "number"
    },
    {
        "name": "supressedDefectsCount",
        "baseName": "supressedDefects_count",
        "type": "number"
    },
    {
        "name": "count",
        "baseName": "count",
        "type": "number"
    },
    {
        "name": "page",
        "baseName": "page",
        "type": "number"
    },
    {
        "name": "defects",
        "baseName": "defects",
        "type": "Array<DefectDetailResponse>"
    },
    {
        "name": "qualityModel",
        "baseName": "quality_model",
        "type": "string"
    },
    {
        "name": "orderedBy",
        "baseName": "ordered_by",
        "type": "string"
    },
    {
        "name": "riskIndex",
        "baseName": "Risk index",
        "type": "MetricValueData"
    },
    {
        "name": "qualityIndicator",
        "baseName": "Quality indicator",
        "type": "MetricValueData"
    },
    {
        "name": "effortToTarget",
        "baseName": "Effort to target",
        "type": "MetricValueData"
    },
    {
        "name": "mainMetrics",
        "baseName": "Main metrics",
        "type": "Array<MetricValueData>"
    },
    {
        "name": "security",
        "baseName": "Security",
        "type": "{ [key: string]: any; }"
    }
];
exports.AnalysisDefectsResponse = AnalysisDefectsResponse;
(function (AnalysisDefectsResponse) {
    let ApplicationBusinessValueEnum;
    (function (ApplicationBusinessValueEnum) {
        ApplicationBusinessValueEnum[ApplicationBusinessValueEnum["VERYLOW"] = 'VERY LOW'] = "VERYLOW";
        ApplicationBusinessValueEnum[ApplicationBusinessValueEnum["LOW"] = 'LOW'] = "LOW";
        ApplicationBusinessValueEnum[ApplicationBusinessValueEnum["MEDIUM"] = 'MEDIUM'] = "MEDIUM";
        ApplicationBusinessValueEnum[ApplicationBusinessValueEnum["HIGH"] = 'HIGH'] = "HIGH";
        ApplicationBusinessValueEnum[ApplicationBusinessValueEnum["CRITICAL"] = 'CRITICAL'] = "CRITICAL";
    })(ApplicationBusinessValueEnum = AnalysisDefectsResponse.ApplicationBusinessValueEnum || (AnalysisDefectsResponse.ApplicationBusinessValueEnum = {}));
    let AnalysisBusinessValueEnum;
    (function (AnalysisBusinessValueEnum) {
        AnalysisBusinessValueEnum[AnalysisBusinessValueEnum["VERYLOW"] = 'VERY LOW'] = "VERYLOW";
        AnalysisBusinessValueEnum[AnalysisBusinessValueEnum["LOW"] = 'LOW'] = "LOW";
        AnalysisBusinessValueEnum[AnalysisBusinessValueEnum["MEDIUM"] = 'MEDIUM'] = "MEDIUM";
        AnalysisBusinessValueEnum[AnalysisBusinessValueEnum["HIGH"] = 'HIGH'] = "HIGH";
        AnalysisBusinessValueEnum[AnalysisBusinessValueEnum["CRITICAL"] = 'CRITICAL'] = "CRITICAL";
    })(AnalysisBusinessValueEnum = AnalysisDefectsResponse.AnalysisBusinessValueEnum || (AnalysisDefectsResponse.AnalysisBusinessValueEnum = {}));
    let AnalysisStatusEnum;
    (function (AnalysisStatusEnum) {
        AnalysisStatusEnum[AnalysisStatusEnum["EXECUTING"] = 'EXECUTING'] = "EXECUTING";
        AnalysisStatusEnum[AnalysisStatusEnum["FINISHED"] = 'FINISHED'] = "FINISHED";
        AnalysisStatusEnum[AnalysisStatusEnum["FINISHEDWITHERROR"] = 'FINISHED_WITH_ERROR'] = "FINISHEDWITHERROR";
    })(AnalysisStatusEnum = AnalysisDefectsResponse.AnalysisStatusEnum || (AnalysisDefectsResponse.AnalysisStatusEnum = {}));
})(AnalysisDefectsResponse = exports.AnalysisDefectsResponse || (exports.AnalysisDefectsResponse = {}));
class AnalysisFilesResponse {
    static getAttributeTypeMap() {
        return AnalysisFilesResponse.attributeTypeMap;
    }
}
AnalysisFilesResponse.discriminator = undefined;
AnalysisFilesResponse.attributeTypeMap = [
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "description",
        "baseName": "description",
        "type": "string"
    },
    {
        "name": "auditName",
        "baseName": "auditName",
        "type": "string"
    },
    {
        "name": "applicationBusinessValue",
        "baseName": "applicationBusinessValue",
        "type": "AnalysisFilesResponse.ApplicationBusinessValueEnum"
    },
    {
        "name": "applicationProvider",
        "baseName": "applicationProvider",
        "type": "string"
    },
    {
        "name": "applicationPortfolios",
        "baseName": "applicationPortfolios",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "label",
        "baseName": "label",
        "type": "string"
    },
    {
        "name": "date",
        "baseName": "date",
        "type": "string"
    },
    {
        "name": "modelId",
        "baseName": "modelId",
        "type": "number"
    },
    {
        "name": "encoding",
        "baseName": "encoding",
        "type": "string"
    },
    {
        "name": "analysisCode",
        "baseName": "analysisCode",
        "type": "string"
    },
    {
        "name": "analysisURL",
        "baseName": "analysisURL",
        "type": "string"
    },
    {
        "name": "auditResultURL",
        "baseName": "auditResultURL",
        "type": "string"
    },
    {
        "name": "analysisBusinessValue",
        "baseName": "analysisBusinessValue",
        "type": "AnalysisFilesResponse.AnalysisBusinessValueEnum"
    },
    {
        "name": "analysisProvider",
        "baseName": "analysisProvider",
        "type": "string"
    },
    {
        "name": "analysisPortfolios",
        "baseName": "analysisPortfolios",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "analysisStatus",
        "baseName": "analysisStatus",
        "type": "AnalysisFilesResponse.AnalysisStatusEnum"
    },
    {
        "name": "languages",
        "baseName": "languages",
        "type": "Array<MetricValueData>"
    },
    {
        "name": "architecture",
        "baseName": "architecture",
        "type": "MetadataArchitectureData"
    },
    {
        "name": "insightsData",
        "baseName": "insightsData",
        "type": "MetadataInsightsData"
    },
    {
        "name": "filesCount",
        "baseName": "files_count",
        "type": "number"
    },
    {
        "name": "count",
        "baseName": "count",
        "type": "number"
    },
    {
        "name": "page",
        "baseName": "page",
        "type": "number"
    },
    {
        "name": "files",
        "baseName": "files",
        "type": "Array<FileData>"
    },
    {
        "name": "qualityModel",
        "baseName": "quality_model",
        "type": "string"
    },
    {
        "name": "orderedBy",
        "baseName": "ordered_by",
        "type": "string"
    },
    {
        "name": "riskIndex",
        "baseName": "Risk index",
        "type": "MetricValueData"
    },
    {
        "name": "qualityIndicator",
        "baseName": "Quality indicator",
        "type": "MetricValueData"
    },
    {
        "name": "effortToTarget",
        "baseName": "Effort to target",
        "type": "MetricValueData"
    },
    {
        "name": "mainMetrics",
        "baseName": "Main metrics",
        "type": "Array<MetricValueData>"
    },
    {
        "name": "security",
        "baseName": "Security",
        "type": "{ [key: string]: any; }"
    }
];
exports.AnalysisFilesResponse = AnalysisFilesResponse;
(function (AnalysisFilesResponse) {
    let ApplicationBusinessValueEnum;
    (function (ApplicationBusinessValueEnum) {
        ApplicationBusinessValueEnum[ApplicationBusinessValueEnum["VERYLOW"] = 'VERY LOW'] = "VERYLOW";
        ApplicationBusinessValueEnum[ApplicationBusinessValueEnum["LOW"] = 'LOW'] = "LOW";
        ApplicationBusinessValueEnum[ApplicationBusinessValueEnum["MEDIUM"] = 'MEDIUM'] = "MEDIUM";
        ApplicationBusinessValueEnum[ApplicationBusinessValueEnum["HIGH"] = 'HIGH'] = "HIGH";
        ApplicationBusinessValueEnum[ApplicationBusinessValueEnum["CRITICAL"] = 'CRITICAL'] = "CRITICAL";
    })(ApplicationBusinessValueEnum = AnalysisFilesResponse.ApplicationBusinessValueEnum || (AnalysisFilesResponse.ApplicationBusinessValueEnum = {}));
    let AnalysisBusinessValueEnum;
    (function (AnalysisBusinessValueEnum) {
        AnalysisBusinessValueEnum[AnalysisBusinessValueEnum["VERYLOW"] = 'VERY LOW'] = "VERYLOW";
        AnalysisBusinessValueEnum[AnalysisBusinessValueEnum["LOW"] = 'LOW'] = "LOW";
        AnalysisBusinessValueEnum[AnalysisBusinessValueEnum["MEDIUM"] = 'MEDIUM'] = "MEDIUM";
        AnalysisBusinessValueEnum[AnalysisBusinessValueEnum["HIGH"] = 'HIGH'] = "HIGH";
        AnalysisBusinessValueEnum[AnalysisBusinessValueEnum["CRITICAL"] = 'CRITICAL'] = "CRITICAL";
    })(AnalysisBusinessValueEnum = AnalysisFilesResponse.AnalysisBusinessValueEnum || (AnalysisFilesResponse.AnalysisBusinessValueEnum = {}));
    let AnalysisStatusEnum;
    (function (AnalysisStatusEnum) {
        AnalysisStatusEnum[AnalysisStatusEnum["EXECUTING"] = 'EXECUTING'] = "EXECUTING";
        AnalysisStatusEnum[AnalysisStatusEnum["FINISHED"] = 'FINISHED'] = "FINISHED";
        AnalysisStatusEnum[AnalysisStatusEnum["FINISHEDWITHERROR"] = 'FINISHED_WITH_ERROR'] = "FINISHEDWITHERROR";
    })(AnalysisStatusEnum = AnalysisFilesResponse.AnalysisStatusEnum || (AnalysisFilesResponse.AnalysisStatusEnum = {}));
})(AnalysisFilesResponse = exports.AnalysisFilesResponse || (exports.AnalysisFilesResponse = {}));
class AnalysisResponse {
    static getAttributeTypeMap() {
        return AnalysisResponse.attributeTypeMap;
    }
}
AnalysisResponse.discriminator = undefined;
AnalysisResponse.attributeTypeMap = [
    {
        "name": "code",
        "baseName": "code",
        "type": "string"
    },
    {
        "name": "label",
        "baseName": "label",
        "type": "string"
    },
    {
        "name": "creationDate",
        "baseName": "creationDate",
        "type": "string"
    },
    {
        "name": "qualityModel",
        "baseName": "qualityModel",
        "type": "string"
    },
    {
        "name": "modelId",
        "baseName": "modelId",
        "type": "string"
    },
    {
        "name": "encoding",
        "baseName": "encoding",
        "type": "string"
    },
    {
        "name": "invoker",
        "baseName": "invoker",
        "type": "string"
    },
    {
        "name": "status",
        "baseName": "status",
        "type": "AnalysisResponse.StatusEnum"
    },
    {
        "name": "errorCode",
        "baseName": "errorCode",
        "type": "string"
    },
    {
        "name": "unparsedFiles",
        "baseName": "unparsedFiles",
        "type": "Array<UnparsedFileData>"
    },
    {
        "name": "analysisScope",
        "baseName": "analysisScope",
        "type": "AnalysisResponse.AnalysisScopeEnum"
    },
    {
        "name": "changeRequest",
        "baseName": "changeRequest",
        "type": "string"
    },
    {
        "name": "changeRequestStatus",
        "baseName": "changeRequestStatus",
        "type": "AnalysisResponse.ChangeRequestStatusEnum"
    },
    {
        "name": "branchName",
        "baseName": "branchName",
        "type": "string"
    },
    {
        "name": "auditResult",
        "baseName": "auditResult",
        "type": "string"
    },
    {
        "name": "analysisBusinessValue",
        "baseName": "analysisBusinessValue",
        "type": "AnalysisResponse.AnalysisBusinessValueEnum"
    },
    {
        "name": "analysisProvider",
        "baseName": "analysisProvider",
        "type": "string"
    },
    {
        "name": "analysisPortfolios",
        "baseName": "analysisPortfolios",
        "type": "{ [key: string]: any; }"
    },
    {
        "name": "metrics",
        "baseName": "metrics",
        "type": "{ [key: string]: number; }"
    }
];
exports.AnalysisResponse = AnalysisResponse;
(function (AnalysisResponse) {
    let StatusEnum;
    (function (StatusEnum) {
        StatusEnum[StatusEnum["INQUEUE"] = 'INQUEUE'] = "INQUEUE";
        StatusEnum[StatusEnum["FAIL"] = 'FAIL'] = "FAIL";
        StatusEnum[StatusEnum["SUCCESS"] = 'SUCCESS'] = "SUCCESS";
        StatusEnum[StatusEnum["RUNNING"] = 'RUNNING'] = "RUNNING";
    })(StatusEnum = AnalysisResponse.StatusEnum || (AnalysisResponse.StatusEnum = {}));
    let AnalysisScopeEnum;
    (function (AnalysisScopeEnum) {
        AnalysisScopeEnum[AnalysisScopeEnum["Baseline"] = 'Baseline'] = "Baseline";
        AnalysisScopeEnum[AnalysisScopeEnum["CompleteDelivery"] = 'Complete delivery'] = "CompleteDelivery";
        AnalysisScopeEnum[AnalysisScopeEnum["PartialDelivery"] = 'Partial delivery'] = "PartialDelivery";
    })(AnalysisScopeEnum = AnalysisResponse.AnalysisScopeEnum || (AnalysisResponse.AnalysisScopeEnum = {}));
    let ChangeRequestStatusEnum;
    (function (ChangeRequestStatusEnum) {
        ChangeRequestStatusEnum[ChangeRequestStatusEnum["Resolved"] = 'Resolved'] = "Resolved";
        ChangeRequestStatusEnum[ChangeRequestStatusEnum["InProgress"] = 'In progress'] = "InProgress";
    })(ChangeRequestStatusEnum = AnalysisResponse.ChangeRequestStatusEnum || (AnalysisResponse.ChangeRequestStatusEnum = {}));
    let AnalysisBusinessValueEnum;
    (function (AnalysisBusinessValueEnum) {
        AnalysisBusinessValueEnum[AnalysisBusinessValueEnum["VERYLOW"] = 'VERY LOW'] = "VERYLOW";
        AnalysisBusinessValueEnum[AnalysisBusinessValueEnum["LOW"] = 'LOW'] = "LOW";
        AnalysisBusinessValueEnum[AnalysisBusinessValueEnum["MEDIUM"] = 'MEDIUM'] = "MEDIUM";
        AnalysisBusinessValueEnum[AnalysisBusinessValueEnum["HIGH"] = 'HIGH'] = "HIGH";
        AnalysisBusinessValueEnum[AnalysisBusinessValueEnum["CRITICAL"] = 'CRITICAL'] = "CRITICAL";
    })(AnalysisBusinessValueEnum = AnalysisResponse.AnalysisBusinessValueEnum || (AnalysisResponse.AnalysisBusinessValueEnum = {}));
})(AnalysisResponse = exports.AnalysisResponse || (exports.AnalysisResponse = {}));
class AnalysisResultResponse {
    static getAttributeTypeMap() {
        return AnalysisResultResponse.attributeTypeMap;
    }
}
AnalysisResultResponse.discriminator = undefined;
AnalysisResultResponse.attributeTypeMap = [
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "description",
        "baseName": "description",
        "type": "string"
    },
    {
        "name": "auditName",
        "baseName": "auditName",
        "type": "string"
    },
    {
        "name": "applicationBusinessValue",
        "baseName": "applicationBusinessValue",
        "type": "AnalysisResultResponse.ApplicationBusinessValueEnum"
    },
    {
        "name": "applicationProvider",
        "baseName": "applicationProvider",
        "type": "string"
    },
    {
        "name": "applicationPortfolios",
        "baseName": "applicationPortfolios",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "label",
        "baseName": "label",
        "type": "string"
    },
    {
        "name": "date",
        "baseName": "date",
        "type": "string"
    },
    {
        "name": "modelId",
        "baseName": "modelId",
        "type": "number"
    },
    {
        "name": "encoding",
        "baseName": "encoding",
        "type": "string"
    },
    {
        "name": "analysisCode",
        "baseName": "analysisCode",
        "type": "string"
    },
    {
        "name": "analysisURL",
        "baseName": "analysisURL",
        "type": "string"
    },
    {
        "name": "auditResultURL",
        "baseName": "auditResultURL",
        "type": "string"
    },
    {
        "name": "analysisBusinessValue",
        "baseName": "analysisBusinessValue",
        "type": "AnalysisResultResponse.AnalysisBusinessValueEnum"
    },
    {
        "name": "analysisProvider",
        "baseName": "analysisProvider",
        "type": "string"
    },
    {
        "name": "analysisPortfolios",
        "baseName": "analysisPortfolios",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "analysisStatus",
        "baseName": "analysisStatus",
        "type": "AnalysisResultResponse.AnalysisStatusEnum"
    },
    {
        "name": "languages",
        "baseName": "languages",
        "type": "Array<MetricValueData>"
    },
    {
        "name": "architecture",
        "baseName": "architecture",
        "type": "MetadataArchitectureData"
    },
    {
        "name": "insightsData",
        "baseName": "insightsData",
        "type": "MetadataInsightsData"
    },
    {
        "name": "analysisScope",
        "baseName": "analysisScope",
        "type": "AnalysisResultResponse.AnalysisScopeEnum"
    },
    {
        "name": "changeRequest",
        "baseName": "changeRequest",
        "type": "string"
    },
    {
        "name": "changeRequestStatus",
        "baseName": "changeRequestStatus",
        "type": "AnalysisResultResponse.ChangeRequestStatusEnum"
    },
    {
        "name": "branchName",
        "baseName": "branchName",
        "type": "string"
    },
    {
        "name": "baselineAnalysisCode",
        "baseName": "baselineAnalysisCode",
        "type": "string"
    },
    {
        "name": "deliveryFiles",
        "baseName": "deliveryFiles",
        "type": "DeliveryFilesData"
    },
    {
        "name": "deliveryDefects",
        "baseName": "deliveryDefects",
        "type": "DeliveryDefectsData"
    },
    {
        "name": "auditResult",
        "baseName": "auditResult",
        "type": "AuditAnalysisResultResponse"
    },
    {
        "name": "qualityModel",
        "baseName": "quality_model",
        "type": "string"
    },
    {
        "name": "orderedBy",
        "baseName": "ordered_by",
        "type": "string"
    },
    {
        "name": "riskIndex",
        "baseName": "Risk index",
        "type": "MetricValueData"
    },
    {
        "name": "qualityIndicator",
        "baseName": "Quality indicator",
        "type": "MetricValueData"
    },
    {
        "name": "effortToTarget",
        "baseName": "Effort to target",
        "type": "MetricValueData"
    },
    {
        "name": "mainMetrics",
        "baseName": "Main metrics",
        "type": "Array<MetricValueData>"
    },
    {
        "name": "security",
        "baseName": "Security",
        "type": "{ [key: string]: any; }"
    }
];
exports.AnalysisResultResponse = AnalysisResultResponse;
(function (AnalysisResultResponse) {
    let ApplicationBusinessValueEnum;
    (function (ApplicationBusinessValueEnum) {
        ApplicationBusinessValueEnum[ApplicationBusinessValueEnum["VERYLOW"] = 'VERY LOW'] = "VERYLOW";
        ApplicationBusinessValueEnum[ApplicationBusinessValueEnum["LOW"] = 'LOW'] = "LOW";
        ApplicationBusinessValueEnum[ApplicationBusinessValueEnum["MEDIUM"] = 'MEDIUM'] = "MEDIUM";
        ApplicationBusinessValueEnum[ApplicationBusinessValueEnum["HIGH"] = 'HIGH'] = "HIGH";
        ApplicationBusinessValueEnum[ApplicationBusinessValueEnum["CRITICAL"] = 'CRITICAL'] = "CRITICAL";
    })(ApplicationBusinessValueEnum = AnalysisResultResponse.ApplicationBusinessValueEnum || (AnalysisResultResponse.ApplicationBusinessValueEnum = {}));
    let AnalysisBusinessValueEnum;
    (function (AnalysisBusinessValueEnum) {
        AnalysisBusinessValueEnum[AnalysisBusinessValueEnum["VERYLOW"] = 'VERY LOW'] = "VERYLOW";
        AnalysisBusinessValueEnum[AnalysisBusinessValueEnum["LOW"] = 'LOW'] = "LOW";
        AnalysisBusinessValueEnum[AnalysisBusinessValueEnum["MEDIUM"] = 'MEDIUM'] = "MEDIUM";
        AnalysisBusinessValueEnum[AnalysisBusinessValueEnum["HIGH"] = 'HIGH'] = "HIGH";
        AnalysisBusinessValueEnum[AnalysisBusinessValueEnum["CRITICAL"] = 'CRITICAL'] = "CRITICAL";
    })(AnalysisBusinessValueEnum = AnalysisResultResponse.AnalysisBusinessValueEnum || (AnalysisResultResponse.AnalysisBusinessValueEnum = {}));
    let AnalysisStatusEnum;
    (function (AnalysisStatusEnum) {
        AnalysisStatusEnum[AnalysisStatusEnum["EXECUTING"] = 'EXECUTING'] = "EXECUTING";
        AnalysisStatusEnum[AnalysisStatusEnum["FINISHED"] = 'FINISHED'] = "FINISHED";
        AnalysisStatusEnum[AnalysisStatusEnum["FINISHEDWITHERROR"] = 'FINISHED_WITH_ERROR'] = "FINISHEDWITHERROR";
    })(AnalysisStatusEnum = AnalysisResultResponse.AnalysisStatusEnum || (AnalysisResultResponse.AnalysisStatusEnum = {}));
    let AnalysisScopeEnum;
    (function (AnalysisScopeEnum) {
        AnalysisScopeEnum[AnalysisScopeEnum["Baseline"] = 'Baseline'] = "Baseline";
        AnalysisScopeEnum[AnalysisScopeEnum["CompleteDelivery"] = 'Complete delivery'] = "CompleteDelivery";
        AnalysisScopeEnum[AnalysisScopeEnum["PartialDelivery"] = 'Partial delivery'] = "PartialDelivery";
    })(AnalysisScopeEnum = AnalysisResultResponse.AnalysisScopeEnum || (AnalysisResultResponse.AnalysisScopeEnum = {}));
    let ChangeRequestStatusEnum;
    (function (ChangeRequestStatusEnum) {
        ChangeRequestStatusEnum[ChangeRequestStatusEnum["Resolved"] = 'Resolved'] = "Resolved";
        ChangeRequestStatusEnum[ChangeRequestStatusEnum["InProgress"] = 'In progress'] = "InProgress";
    })(ChangeRequestStatusEnum = AnalysisResultResponse.ChangeRequestStatusEnum || (AnalysisResultResponse.ChangeRequestStatusEnum = {}));
})(AnalysisResultResponse = exports.AnalysisResultResponse || (exports.AnalysisResultResponse = {}));
class ApplicationAnalysisResponse {
    static getAttributeTypeMap() {
        return ApplicationAnalysisResponse.attributeTypeMap;
    }
}
ApplicationAnalysisResponse.discriminator = undefined;
ApplicationAnalysisResponse.attributeTypeMap = [
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "description",
        "baseName": "description",
        "type": "string"
    },
    {
        "name": "auditName",
        "baseName": "auditName",
        "type": "string"
    },
    {
        "name": "applicationBusinessValue",
        "baseName": "applicationBusinessValue",
        "type": "ApplicationAnalysisResponse.ApplicationBusinessValueEnum"
    },
    {
        "name": "applicationProvider",
        "baseName": "applicationProvider",
        "type": "string"
    },
    {
        "name": "applicationPortfolios",
        "baseName": "applicationPortfolios",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "label",
        "baseName": "label",
        "type": "string"
    },
    {
        "name": "date",
        "baseName": "date",
        "type": "string"
    },
    {
        "name": "modelId",
        "baseName": "modelId",
        "type": "number"
    },
    {
        "name": "encoding",
        "baseName": "encoding",
        "type": "string"
    },
    {
        "name": "analysisCode",
        "baseName": "analysisCode",
        "type": "string"
    },
    {
        "name": "analysisURL",
        "baseName": "analysisURL",
        "type": "string"
    },
    {
        "name": "auditResultURL",
        "baseName": "auditResultURL",
        "type": "string"
    },
    {
        "name": "analysisBusinessValue",
        "baseName": "analysisBusinessValue",
        "type": "ApplicationAnalysisResponse.AnalysisBusinessValueEnum"
    },
    {
        "name": "analysisProvider",
        "baseName": "analysisProvider",
        "type": "string"
    },
    {
        "name": "analysisPortfolios",
        "baseName": "analysisPortfolios",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "analysisStatus",
        "baseName": "analysisStatus",
        "type": "ApplicationAnalysisResponse.AnalysisStatusEnum"
    },
    {
        "name": "languages",
        "baseName": "languages",
        "type": "Array<MetricValueData>"
    },
    {
        "name": "architecture",
        "baseName": "architecture",
        "type": "MetadataArchitectureData"
    },
    {
        "name": "insightsData",
        "baseName": "insightsData",
        "type": "MetadataInsightsData"
    },
    {
        "name": "qualityModel",
        "baseName": "quality_model",
        "type": "string"
    },
    {
        "name": "orderedBy",
        "baseName": "ordered_by",
        "type": "string"
    },
    {
        "name": "riskIndex",
        "baseName": "Risk index",
        "type": "MetricValueData"
    },
    {
        "name": "qualityIndicator",
        "baseName": "Quality indicator",
        "type": "MetricValueData"
    },
    {
        "name": "effortToTarget",
        "baseName": "Effort to target",
        "type": "MetricValueData"
    },
    {
        "name": "mainMetrics",
        "baseName": "Main metrics",
        "type": "Array<MetricValueData>"
    },
    {
        "name": "security",
        "baseName": "Security",
        "type": "{ [key: string]: any; }"
    }
];
exports.ApplicationAnalysisResponse = ApplicationAnalysisResponse;
(function (ApplicationAnalysisResponse) {
    let ApplicationBusinessValueEnum;
    (function (ApplicationBusinessValueEnum) {
        ApplicationBusinessValueEnum[ApplicationBusinessValueEnum["VERYLOW"] = 'VERY LOW'] = "VERYLOW";
        ApplicationBusinessValueEnum[ApplicationBusinessValueEnum["LOW"] = 'LOW'] = "LOW";
        ApplicationBusinessValueEnum[ApplicationBusinessValueEnum["MEDIUM"] = 'MEDIUM'] = "MEDIUM";
        ApplicationBusinessValueEnum[ApplicationBusinessValueEnum["HIGH"] = 'HIGH'] = "HIGH";
        ApplicationBusinessValueEnum[ApplicationBusinessValueEnum["CRITICAL"] = 'CRITICAL'] = "CRITICAL";
    })(ApplicationBusinessValueEnum = ApplicationAnalysisResponse.ApplicationBusinessValueEnum || (ApplicationAnalysisResponse.ApplicationBusinessValueEnum = {}));
    let AnalysisBusinessValueEnum;
    (function (AnalysisBusinessValueEnum) {
        AnalysisBusinessValueEnum[AnalysisBusinessValueEnum["VERYLOW"] = 'VERY LOW'] = "VERYLOW";
        AnalysisBusinessValueEnum[AnalysisBusinessValueEnum["LOW"] = 'LOW'] = "LOW";
        AnalysisBusinessValueEnum[AnalysisBusinessValueEnum["MEDIUM"] = 'MEDIUM'] = "MEDIUM";
        AnalysisBusinessValueEnum[AnalysisBusinessValueEnum["HIGH"] = 'HIGH'] = "HIGH";
        AnalysisBusinessValueEnum[AnalysisBusinessValueEnum["CRITICAL"] = 'CRITICAL'] = "CRITICAL";
    })(AnalysisBusinessValueEnum = ApplicationAnalysisResponse.AnalysisBusinessValueEnum || (ApplicationAnalysisResponse.AnalysisBusinessValueEnum = {}));
    let AnalysisStatusEnum;
    (function (AnalysisStatusEnum) {
        AnalysisStatusEnum[AnalysisStatusEnum["EXECUTING"] = 'EXECUTING'] = "EXECUTING";
        AnalysisStatusEnum[AnalysisStatusEnum["FINISHED"] = 'FINISHED'] = "FINISHED";
        AnalysisStatusEnum[AnalysisStatusEnum["FINISHEDWITHERROR"] = 'FINISHED_WITH_ERROR'] = "FINISHEDWITHERROR";
    })(AnalysisStatusEnum = ApplicationAnalysisResponse.AnalysisStatusEnum || (ApplicationAnalysisResponse.AnalysisStatusEnum = {}));
})(ApplicationAnalysisResponse = exports.ApplicationAnalysisResponse || (exports.ApplicationAnalysisResponse = {}));
class ApplicationManagementRequest {
    static getAttributeTypeMap() {
        return ApplicationManagementRequest.attributeTypeMap;
    }
}
ApplicationManagementRequest.discriminator = undefined;
ApplicationManagementRequest.attributeTypeMap = [
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "model",
        "baseName": "model",
        "type": "string"
    },
    {
        "name": "description",
        "baseName": "description",
        "type": "string"
    },
    {
        "name": "portfolios",
        "baseName": "portfolios",
        "type": "Array<PortfolioData>"
    },
    {
        "name": "targets",
        "baseName": "targets",
        "type": "{ [key: string]: number; }"
    },
    {
        "name": "newName",
        "baseName": "newName",
        "type": "string"
    },
    {
        "name": "businessValue",
        "baseName": "businessValue",
        "type": "ApplicationManagementRequest.BusinessValueEnum"
    },
    {
        "name": "provider",
        "baseName": "provider",
        "type": "string"
    },
    {
        "name": "modelId",
        "baseName": "modelId",
        "type": "number"
    },
    {
        "name": "newModelId",
        "baseName": "newModelId",
        "type": "number"
    }
];
exports.ApplicationManagementRequest = ApplicationManagementRequest;
(function (ApplicationManagementRequest) {
    let BusinessValueEnum;
    (function (BusinessValueEnum) {
        BusinessValueEnum[BusinessValueEnum["VERYLOW"] = 'VERY LOW'] = "VERYLOW";
        BusinessValueEnum[BusinessValueEnum["LOW"] = 'LOW'] = "LOW";
        BusinessValueEnum[BusinessValueEnum["MEDIUM"] = 'MEDIUM'] = "MEDIUM";
        BusinessValueEnum[BusinessValueEnum["HIGH"] = 'HIGH'] = "HIGH";
        BusinessValueEnum[BusinessValueEnum["CRITICAL"] = 'CRITICAL'] = "CRITICAL";
    })(BusinessValueEnum = ApplicationManagementRequest.BusinessValueEnum || (ApplicationManagementRequest.BusinessValueEnum = {}));
})(ApplicationManagementRequest = exports.ApplicationManagementRequest || (exports.ApplicationManagementRequest = {}));
class ApplicationPermissionsData {
    static getAttributeTypeMap() {
        return ApplicationPermissionsData.attributeTypeMap;
    }
}
ApplicationPermissionsData.discriminator = undefined;
ApplicationPermissionsData.attributeTypeMap = [
    {
        "name": "applicationName",
        "baseName": "applicationName",
        "type": "string"
    },
    {
        "name": "roleName",
        "baseName": "roleName",
        "type": "string"
    },
    {
        "name": "override",
        "baseName": "override",
        "type": "boolean"
    },
    {
        "name": "deleteActionPlans",
        "baseName": "deleteActionPlans",
        "type": "boolean"
    },
    {
        "name": "deleteAnalysis",
        "baseName": "deleteAnalysis",
        "type": "boolean"
    },
    {
        "name": "deleteDeliveries",
        "baseName": "deleteDeliveries",
        "type": "boolean"
    },
    {
        "name": "executeAnalysis",
        "baseName": "executeAnalysis",
        "type": "boolean"
    },
    {
        "name": "executeDeliveries",
        "baseName": "executeDeliveries",
        "type": "boolean"
    },
    {
        "name": "exportActionPlansJira",
        "baseName": "exportActionPlansJira",
        "type": "boolean"
    },
    {
        "name": "muteDefects",
        "baseName": "muteDefects",
        "type": "boolean"
    },
    {
        "name": "saveActionPlans",
        "baseName": "saveActionPlans",
        "type": "boolean"
    },
    {
        "name": "viewApplicationData",
        "baseName": "viewApplicationData",
        "type": "boolean"
    },
    {
        "name": "viewDeliveries",
        "baseName": "viewDeliveries",
        "type": "boolean"
    }
];
exports.ApplicationPermissionsData = ApplicationPermissionsData;
class ApplicationResponse {
    static getAttributeTypeMap() {
        return ApplicationResponse.attributeTypeMap;
    }
}
ApplicationResponse.discriminator = undefined;
ApplicationResponse.attributeTypeMap = [
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "description",
        "baseName": "description",
        "type": "string"
    },
    {
        "name": "auditName",
        "baseName": "auditName",
        "type": "string"
    },
    {
        "name": "applicationBusinessValue",
        "baseName": "applicationBusinessValue",
        "type": "ApplicationResponse.ApplicationBusinessValueEnum"
    },
    {
        "name": "applicationProvider",
        "baseName": "applicationProvider",
        "type": "string"
    },
    {
        "name": "applicationPortfolios",
        "baseName": "applicationPortfolios",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "qualityModel",
        "baseName": "quality_model",
        "type": "string"
    }
];
exports.ApplicationResponse = ApplicationResponse;
(function (ApplicationResponse) {
    let ApplicationBusinessValueEnum;
    (function (ApplicationBusinessValueEnum) {
        ApplicationBusinessValueEnum[ApplicationBusinessValueEnum["VERYLOW"] = 'VERY LOW'] = "VERYLOW";
        ApplicationBusinessValueEnum[ApplicationBusinessValueEnum["LOW"] = 'LOW'] = "LOW";
        ApplicationBusinessValueEnum[ApplicationBusinessValueEnum["MEDIUM"] = 'MEDIUM'] = "MEDIUM";
        ApplicationBusinessValueEnum[ApplicationBusinessValueEnum["HIGH"] = 'HIGH'] = "HIGH";
        ApplicationBusinessValueEnum[ApplicationBusinessValueEnum["CRITICAL"] = 'CRITICAL'] = "CRITICAL";
    })(ApplicationBusinessValueEnum = ApplicationResponse.ApplicationBusinessValueEnum || (ApplicationResponse.ApplicationBusinessValueEnum = {}));
})(ApplicationResponse = exports.ApplicationResponse || (exports.ApplicationResponse = {}));
class ApplicationRoleData {
    static getAttributeTypeMap() {
        return ApplicationRoleData.attributeTypeMap;
    }
}
ApplicationRoleData.discriminator = undefined;
ApplicationRoleData.attributeTypeMap = [
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "roleName",
        "baseName": "roleName",
        "type": "string"
    },
    {
        "name": "override",
        "baseName": "override",
        "type": "boolean"
    }
];
exports.ApplicationRoleData = ApplicationRoleData;
class AuditAnalysisResultResponse {
    static getAttributeTypeMap() {
        return AuditAnalysisResultResponse.attributeTypeMap;
    }
}
AuditAnalysisResultResponse.discriminator = undefined;
AuditAnalysisResultResponse.attributeTypeMap = [
    {
        "name": "auditName",
        "baseName": "auditName",
        "type": "string"
    },
    {
        "name": "description",
        "baseName": "description",
        "type": "string"
    },
    {
        "name": "approvalThreshold",
        "baseName": "approvalThreshold",
        "type": "number"
    },
    {
        "name": "overallResult",
        "baseName": "overallResult",
        "type": "AuditAnalysisResultResponse.OverallResultEnum"
    },
    {
        "name": "score",
        "baseName": "score",
        "type": "number"
    },
    {
        "name": "checkpointResults",
        "baseName": "checkpointResults",
        "type": "Array<CheckpointResultData>"
    }
];
exports.AuditAnalysisResultResponse = AuditAnalysisResultResponse;
(function (AuditAnalysisResultResponse) {
    let OverallResultEnum;
    (function (OverallResultEnum) {
        OverallResultEnum[OverallResultEnum["OK"] = 'OK'] = "OK";
        OverallResultEnum[OverallResultEnum["FAIL"] = 'FAIL'] = "FAIL";
    })(OverallResultEnum = AuditAnalysisResultResponse.OverallResultEnum || (AuditAnalysisResultResponse.OverallResultEnum = {}));
})(AuditAnalysisResultResponse = exports.AuditAnalysisResultResponse || (exports.AuditAnalysisResultResponse = {}));
class AuditResultResponse {
    static getAttributeTypeMap() {
        return AuditResultResponse.attributeTypeMap;
    }
}
AuditResultResponse.discriminator = undefined;
AuditResultResponse.attributeTypeMap = [
    {
        "name": "analysisCode",
        "baseName": "analysisCode",
        "type": "string"
    },
    {
        "name": "passAudit",
        "baseName": "passAudit",
        "type": "boolean"
    },
    {
        "name": "label",
        "baseName": "label",
        "type": "string"
    },
    {
        "name": "creationTimestamp",
        "baseName": "creationTimestamp",
        "type": "string"
    },
    {
        "name": "metrics",
        "baseName": "metrics",
        "type": "{ [key: string]: number; }"
    }
];
exports.AuditResultResponse = AuditResultResponse;
class AuthorizationResponse {
    static getAttributeTypeMap() {
        return AuthorizationResponse.attributeTypeMap;
    }
}
AuthorizationResponse.discriminator = undefined;
AuthorizationResponse.attributeTypeMap = [
    {
        "name": "actionCode",
        "baseName": "actionCode",
        "type": "string"
    },
    {
        "name": "granted",
        "baseName": "granted",
        "type": "boolean"
    }
];
exports.AuthorizationResponse = AuthorizationResponse;
class BusinessValuePortfolioRoleData {
    static getAttributeTypeMap() {
        return BusinessValuePortfolioRoleData.attributeTypeMap;
    }
}
BusinessValuePortfolioRoleData.discriminator = undefined;
BusinessValuePortfolioRoleData.attributeTypeMap = [
    {
        "name": "type",
        "baseName": "type",
        "type": "BusinessValuePortfolioRoleData.TypeEnum"
    },
    {
        "name": "portfolioValue",
        "baseName": "portfolioValue",
        "type": "string"
    },
    {
        "name": "roleName",
        "baseName": "roleName",
        "type": "string"
    }
];
exports.BusinessValuePortfolioRoleData = BusinessValuePortfolioRoleData;
(function (BusinessValuePortfolioRoleData) {
    let TypeEnum;
    (function (TypeEnum) {
        TypeEnum[TypeEnum["SYSTEM"] = 'SYSTEM'] = "SYSTEM";
    })(TypeEnum = BusinessValuePortfolioRoleData.TypeEnum || (BusinessValuePortfolioRoleData.TypeEnum = {}));
})(BusinessValuePortfolioRoleData = exports.BusinessValuePortfolioRoleData || (exports.BusinessValuePortfolioRoleData = {}));
class CheckpointResultData {
    static getAttributeTypeMap() {
        return CheckpointResultData.attributeTypeMap;
    }
}
CheckpointResultData.discriminator = undefined;
CheckpointResultData.attributeTypeMap = [
    {
        "name": "checkpoint",
        "baseName": "checkpoint",
        "type": "string"
    },
    {
        "name": "result",
        "baseName": "result",
        "type": "CheckpointResultData.ResultEnum"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "description",
        "baseName": "description",
        "type": "string"
    },
    {
        "name": "weight",
        "baseName": "weight",
        "type": "number"
    },
    {
        "name": "mandatory",
        "baseName": "mandatory",
        "type": "boolean"
    },
    {
        "name": "type",
        "baseName": "type",
        "type": "string"
    },
    {
        "name": "score",
        "baseName": "score",
        "type": "number"
    },
    {
        "name": "violatedRules",
        "baseName": "violatedRules",
        "type": "Array<ViolatedRuleResponse>"
    }
];
exports.CheckpointResultData = CheckpointResultData;
(function (CheckpointResultData) {
    let ResultEnum;
    (function (ResultEnum) {
        ResultEnum[ResultEnum["OK"] = 'OK'] = "OK";
        ResultEnum[ResultEnum["FAIL"] = 'FAIL'] = "FAIL";
    })(ResultEnum = CheckpointResultData.ResultEnum || (CheckpointResultData.ResultEnum = {}));
})(CheckpointResultData = exports.CheckpointResultData || (exports.CheckpointResultData = {}));
class ComponentDetailResponse {
    static getAttributeTypeMap() {
        return ComponentDetailResponse.attributeTypeMap;
    }
}
ComponentDetailResponse.discriminator = undefined;
ComponentDetailResponse.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "id",
        "type": "number"
    },
    {
        "name": "dn",
        "baseName": "dn",
        "type": "string"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "type",
        "baseName": "type",
        "type": "string"
    },
    {
        "name": "language",
        "baseName": "language",
        "type": "string"
    },
    {
        "name": "tags",
        "baseName": "tags",
        "type": "Array<any>"
    },
    {
        "name": "grouptags",
        "baseName": "grouptags",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "artifacts",
        "baseName": "artifacts",
        "type": "Array<any>"
    },
    {
        "name": "analyzed",
        "baseName": "analyzed",
        "type": "boolean"
    },
    {
        "name": "loc",
        "baseName": "loc",
        "type": "number"
    },
    {
        "name": "quality",
        "baseName": "quality",
        "type": "number"
    },
    {
        "name": "dupCode",
        "baseName": "dupCode",
        "type": "number"
    },
    {
        "name": "ccn",
        "baseName": "ccn",
        "type": "number"
    },
    {
        "name": "effort",
        "baseName": "effort",
        "type": "number"
    },
    {
        "name": "groupedCount",
        "baseName": "groupedCount",
        "type": "number"
    },
    {
        "name": "other",
        "baseName": "other",
        "type": "{ [key: string]: any; }"
    }
];
exports.ComponentDetailResponse = ComponentDetailResponse;
class ComponentSimpleRestData {
    static getAttributeTypeMap() {
        return ComponentSimpleRestData.attributeTypeMap;
    }
}
ComponentSimpleRestData.discriminator = undefined;
ComponentSimpleRestData.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "id",
        "type": "number"
    },
    {
        "name": "artifact",
        "baseName": "artifact",
        "type": "string"
    },
    {
        "name": "version",
        "baseName": "version",
        "type": "string"
    },
    {
        "name": "description",
        "baseName": "description",
        "type": "string"
    }
];
exports.ComponentSimpleRestData = ComponentSimpleRestData;
class DataFlowElement {
    static getAttributeTypeMap() {
        return DataFlowElement.attributeTypeMap;
    }
}
DataFlowElement.discriminator = undefined;
DataFlowElement.attributeTypeMap = [
    {
        "name": "file",
        "baseName": "file",
        "type": "string"
    },
    {
        "name": "lineNumber",
        "baseName": "lineNumber",
        "type": "number"
    },
    {
        "name": "columnNumber",
        "baseName": "columnNumber",
        "type": "number"
    },
    {
        "name": "parameter",
        "baseName": "parameter",
        "type": "string"
    },
    {
        "name": "text",
        "baseName": "text",
        "type": "string"
    },
    {
        "name": "sequence",
        "baseName": "sequence",
        "type": "number"
    }
];
exports.DataFlowElement = DataFlowElement;
class DatapathData {
    static getAttributeTypeMap() {
        return DatapathData.attributeTypeMap;
    }
}
DatapathData.discriminator = undefined;
DatapathData.attributeTypeMap = [
    {
        "name": "index",
        "baseName": "index",
        "type": "number"
    },
    {
        "name": "kind",
        "baseName": "kind",
        "type": "DatapathData.KindEnum"
    },
    {
        "name": "varname",
        "baseName": "varname",
        "type": "string"
    },
    {
        "name": "lineNumber",
        "baseName": "lineNumber",
        "type": "number"
    },
    {
        "name": "lineText",
        "baseName": "lineText",
        "type": "string"
    },
    {
        "name": "indirect",
        "baseName": "indirect",
        "type": "boolean"
    },
    {
        "name": "file",
        "baseName": "file",
        "type": "string"
    },
    {
        "name": "container",
        "baseName": "container",
        "type": "string"
    },
    {
        "name": "localId",
        "baseName": "localId",
        "type": "number"
    },
    {
        "name": "localParentId",
        "baseName": "localParentId",
        "type": "number"
    }
];
exports.DatapathData = DatapathData;
(function (DatapathData) {
    let KindEnum;
    (function (KindEnum) {
        KindEnum[KindEnum["Assign"] = 'assign'] = "Assign";
        KindEnum[KindEnum["Call"] = 'call'] = "Call";
        KindEnum[KindEnum["Other"] = 'other'] = "Other";
        KindEnum[KindEnum["Sink"] = 'sink'] = "Sink";
        KindEnum[KindEnum["Source"] = 'source'] = "Source";
    })(KindEnum = DatapathData.KindEnum || (DatapathData.KindEnum = {}));
})(DatapathData = exports.DatapathData || (exports.DatapathData = {}));
class DefectDetailResponse {
    static getAttributeTypeMap() {
        return DefectDetailResponse.attributeTypeMap;
    }
}
DefectDetailResponse.discriminator = undefined;
DefectDetailResponse.attributeTypeMap = [
    {
        "name": "defectId",
        "baseName": "defectId",
        "type": "number"
    },
    {
        "name": "file",
        "baseName": "file",
        "type": "string"
    },
    {
        "name": "line",
        "baseName": "line",
        "type": "number"
    },
    {
        "name": "code",
        "baseName": "code",
        "type": "string"
    },
    {
        "name": "muted",
        "baseName": "muted",
        "type": "boolean"
    },
    {
        "name": "vulnerabilityType",
        "baseName": "vulnerabilityType",
        "type": "string"
    },
    {
        "name": "explanation",
        "baseName": "explanation",
        "type": "string"
    },
    {
        "name": "status",
        "baseName": "status",
        "type": "DefectDetailResponse.StatusEnum"
    },
    {
        "name": "cweId",
        "baseName": "cweId",
        "type": "number"
    },
    {
        "name": "ruleCode",
        "baseName": "ruleCode",
        "type": "string"
    },
    {
        "name": "rule",
        "baseName": "rule",
        "type": "string"
    },
    {
        "name": "language",
        "baseName": "language",
        "type": "string"
    },
    {
        "name": "characteristic",
        "baseName": "characteristic",
        "type": "DefectDetailResponse.CharacteristicEnum"
    },
    {
        "name": "priority",
        "baseName": "priority",
        "type": "DefectDetailResponse.PriorityEnum"
    },
    {
        "name": "effort",
        "baseName": "effort",
        "type": "string"
    },
    {
        "name": "modelId",
        "baseName": "modelId",
        "type": "number"
    },
    {
        "name": "securityDetail",
        "baseName": "securityDetail",
        "type": "VulnerabilityData"
    }
];
exports.DefectDetailResponse = DefectDetailResponse;
(function (DefectDetailResponse) {
    let StatusEnum;
    (function (StatusEnum) {
        StatusEnum[StatusEnum["None"] = 'None'] = "None";
        StatusEnum[StatusEnum["ToReview"] = 'To review'] = "ToReview";
        StatusEnum[StatusEnum["Reviewed"] = 'Reviewed'] = "Reviewed";
    })(StatusEnum = DefectDetailResponse.StatusEnum || (DefectDetailResponse.StatusEnum = {}));
    let CharacteristicEnum;
    (function (CharacteristicEnum) {
        CharacteristicEnum[CharacteristicEnum["Efficiency"] = 'Efficiency'] = "Efficiency";
        CharacteristicEnum[CharacteristicEnum["Maintainability"] = 'Maintainability'] = "Maintainability";
        CharacteristicEnum[CharacteristicEnum["Portability"] = 'Portability'] = "Portability";
        CharacteristicEnum[CharacteristicEnum["Reliability"] = 'Reliability'] = "Reliability";
        CharacteristicEnum[CharacteristicEnum["Security"] = 'Security'] = "Security";
    })(CharacteristicEnum = DefectDetailResponse.CharacteristicEnum || (DefectDetailResponse.CharacteristicEnum = {}));
    let PriorityEnum;
    (function (PriorityEnum) {
        PriorityEnum[PriorityEnum["VeryLow"] = 'Very Low'] = "VeryLow";
        PriorityEnum[PriorityEnum["Low"] = 'Low'] = "Low";
        PriorityEnum[PriorityEnum["Normal"] = 'Normal'] = "Normal";
        PriorityEnum[PriorityEnum["High"] = 'High'] = "High";
        PriorityEnum[PriorityEnum["VeryHigh"] = 'Very High'] = "VeryHigh";
    })(PriorityEnum = DefectDetailResponse.PriorityEnum || (DefectDetailResponse.PriorityEnum = {}));
})(DefectDetailResponse = exports.DefectDetailResponse || (exports.DefectDetailResponse = {}));
class DefectLineResponse {
    static getAttributeTypeMap() {
        return DefectLineResponse.attributeTypeMap;
    }
}
DefectLineResponse.discriminator = undefined;
DefectLineResponse.attributeTypeMap = [
    {
        "name": "code",
        "baseName": "code",
        "type": "string"
    },
    {
        "name": "line",
        "baseName": "line",
        "type": "number"
    },
    {
        "name": "muted",
        "baseName": "muted",
        "type": "boolean"
    }
];
exports.DefectLineResponse = DefectLineResponse;
class DefectNoteResponse {
    static getAttributeTypeMap() {
        return DefectNoteResponse.attributeTypeMap;
    }
}
DefectNoteResponse.discriminator = undefined;
DefectNoteResponse.attributeTypeMap = [
    {
        "name": "date",
        "baseName": "date",
        "type": "string"
    },
    {
        "name": "user",
        "baseName": "user",
        "type": "string"
    },
    {
        "name": "text",
        "baseName": "text",
        "type": "string"
    }
];
exports.DefectNoteResponse = DefectNoteResponse;
class DefectsDeltaDetailResponse {
    static getAttributeTypeMap() {
        return DefectsDeltaDetailResponse.attributeTypeMap;
    }
}
DefectsDeltaDetailResponse.discriminator = undefined;
DefectsDeltaDetailResponse.attributeTypeMap = [
    {
        "name": "count",
        "baseName": "count",
        "type": "number"
    },
    {
        "name": "page",
        "baseName": "page",
        "type": "number"
    },
    {
        "name": "mainAnalysisCode",
        "baseName": "Main analysis code",
        "type": "string"
    },
    {
        "name": "previousAnalysisCode",
        "baseName": "Previous analysis code",
        "type": "string"
    },
    {
        "name": "newViolatedRulesCount",
        "baseName": "New violated rules count",
        "type": "number"
    },
    {
        "name": "removedViolatedRulesCount",
        "baseName": "Removed violated rules count",
        "type": "number"
    },
    {
        "name": "newDefectsCount",
        "baseName": "New defects count",
        "type": "number"
    },
    {
        "name": "removedDefectsCount",
        "baseName": "Removed defects count",
        "type": "number"
    },
    {
        "name": "newDefects",
        "baseName": "New defects",
        "type": "Array<DefectDetailResponse>"
    },
    {
        "name": "removedDefects",
        "baseName": "Removed defects",
        "type": "Array<DefectDetailResponse>"
    }
];
exports.DefectsDeltaDetailResponse = DefectsDeltaDetailResponse;
class DefectsDeltaResponse {
    static getAttributeTypeMap() {
        return DefectsDeltaResponse.attributeTypeMap;
    }
}
DefectsDeltaResponse.discriminator = undefined;
DefectsDeltaResponse.attributeTypeMap = [
    {
        "name": "mainAnalysisCode",
        "baseName": "Main analysis code",
        "type": "string"
    },
    {
        "name": "previousAnalysisCode",
        "baseName": "Previous analysis code",
        "type": "string"
    },
    {
        "name": "newViolatedRulesCount",
        "baseName": "New violated rules count",
        "type": "number"
    },
    {
        "name": "removedViolatedRulesCount",
        "baseName": "Removed violated rules count",
        "type": "number"
    },
    {
        "name": "newDefectsCount",
        "baseName": "New defects count",
        "type": "number"
    },
    {
        "name": "removedDefectsCount",
        "baseName": "Removed defects count",
        "type": "number"
    }
];
exports.DefectsDeltaResponse = DefectsDeltaResponse;
class DeliveryDefectsData {
    static getAttributeTypeMap() {
        return DeliveryDefectsData.attributeTypeMap;
    }
}
DeliveryDefectsData.discriminator = undefined;
DeliveryDefectsData.attributeTypeMap = [
    {
        "name": "newDefects",
        "baseName": "newDefects",
        "type": "number"
    },
    {
        "name": "removedDefects",
        "baseName": "removedDefects",
        "type": "number"
    },
    {
        "name": "defects",
        "baseName": "defects",
        "type": "number"
    }
];
exports.DeliveryDefectsData = DeliveryDefectsData;
class DeliveryFilesData {
    static getAttributeTypeMap() {
        return DeliveryFilesData.attributeTypeMap;
    }
}
DeliveryFilesData.discriminator = undefined;
DeliveryFilesData.attributeTypeMap = [
    {
        "name": "count",
        "baseName": "count",
        "type": "number"
    }
];
exports.DeliveryFilesData = DeliveryFilesData;
class FileData {
    static getAttributeTypeMap() {
        return FileData.attributeTypeMap;
    }
}
FileData.discriminator = undefined;
FileData.attributeTypeMap = [
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "metricsCount",
        "baseName": "metrics_count",
        "type": "number"
    },
    {
        "name": "metrics",
        "baseName": "metrics",
        "type": "Array<MetricValueData>"
    },
    {
        "name": "defectsCount",
        "baseName": "defects_count",
        "type": "number"
    },
    {
        "name": "defects",
        "baseName": "defects",
        "type": "Array<DefectDetailResponse>"
    }
];
exports.FileData = FileData;
class FileWithDefectsResponse {
    static getAttributeTypeMap() {
        return FileWithDefectsResponse.attributeTypeMap;
    }
}
FileWithDefectsResponse.discriminator = undefined;
FileWithDefectsResponse.attributeTypeMap = [
    {
        "name": "file",
        "baseName": "file",
        "type": "string"
    },
    {
        "name": "defectsCount",
        "baseName": "defectsCount",
        "type": "number"
    },
    {
        "name": "defects",
        "baseName": "defects",
        "type": "HrefData"
    }
];
exports.FileWithDefectsResponse = FileWithDefectsResponse;
class FilterData {
    static getAttributeTypeMap() {
        return FilterData.attributeTypeMap;
    }
}
FilterData.discriminator = undefined;
FilterData.attributeTypeMap = [
    {
        "name": "contains",
        "baseName": "contains",
        "type": "string"
    },
    {
        "name": "notContains",
        "baseName": "notContains",
        "type": "string"
    },
    {
        "name": "languages",
        "baseName": "languages",
        "type": "string"
    },
    {
        "name": "types",
        "baseName": "types",
        "type": "string"
    },
    {
        "name": "analyzed",
        "baseName": "analyzed",
        "type": "boolean"
    },
    {
        "name": "fileName",
        "baseName": "fileName",
        "type": "string"
    },
    {
        "name": "tags",
        "baseName": "tags",
        "type": "string"
    },
    {
        "name": "groupTags",
        "baseName": "groupTags",
        "type": "Array<GroupTagData>"
    }
];
exports.FilterData = FilterData;
class Finding {
    static getAttributeTypeMap() {
        return Finding.attributeTypeMap;
    }
}
Finding.discriminator = undefined;
Finding.attributeTypeMap = [
    {
        "name": "nativeId",
        "baseName": "nativeId",
        "type": "string"
    },
    {
        "name": "severity",
        "baseName": "severity",
        "type": "Finding.SeverityEnum"
    },
    {
        "name": "nativeSeverity",
        "baseName": "nativeSeverity",
        "type": "string"
    },
    {
        "name": "summary",
        "baseName": "summary",
        "type": "string"
    },
    {
        "name": "mappings",
        "baseName": "mappings",
        "type": "Array<Mapping>"
    },
    {
        "name": "scannerDetail",
        "baseName": "scannerDetail",
        "type": "string"
    },
    {
        "name": "scannerRecommendation",
        "baseName": "scannerRecommendation",
        "type": "string"
    },
    {
        "name": "staticDetails",
        "baseName": "staticDetails",
        "type": "StaticDetails"
    },
    {
        "name": "metadata",
        "baseName": "metadata",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "tags",
        "baseName": "tags",
        "type": "Array<string>"
    },
    {
        "name": "comments",
        "baseName": "comments",
        "type": "Array<string>"
    }
];
exports.Finding = Finding;
(function (Finding) {
    let SeverityEnum;
    (function (SeverityEnum) {
        SeverityEnum[SeverityEnum["UNKNOWN"] = 'UNKNOWN'] = "UNKNOWN";
        SeverityEnum[SeverityEnum["INFO"] = 'INFO'] = "INFO";
        SeverityEnum[SeverityEnum["LOW"] = 'LOW'] = "LOW";
        SeverityEnum[SeverityEnum["MEDIUM"] = 'MEDIUM'] = "MEDIUM";
        SeverityEnum[SeverityEnum["HIGH"] = 'HIGH'] = "HIGH";
        SeverityEnum[SeverityEnum["CRITICAL"] = 'CRITICAL'] = "CRITICAL";
    })(SeverityEnum = Finding.SeverityEnum || (Finding.SeverityEnum = {}));
})(Finding = exports.Finding || (exports.Finding = {}));
class FrameData {
    static getAttributeTypeMap() {
        return FrameData.attributeTypeMap;
    }
}
FrameData.discriminator = undefined;
FrameData.attributeTypeMap = [
    {
        "name": "index",
        "baseName": "index",
        "type": "number"
    },
    {
        "name": "file",
        "baseName": "file",
        "type": "string"
    },
    {
        "name": "lineNumber",
        "baseName": "lineNumber",
        "type": "number"
    },
    {
        "name": "lineText",
        "baseName": "lineText",
        "type": "string"
    },
    {
        "name": "category",
        "baseName": "category",
        "type": "string"
    },
    {
        "name": "resource",
        "baseName": "resource",
        "type": "string"
    },
    {
        "name": "container",
        "baseName": "container",
        "type": "string"
    },
    {
        "name": "injectionPoint",
        "baseName": "injectionPoint",
        "type": "string"
    },
    {
        "name": "variableDeclaration",
        "baseName": "variableDeclaration",
        "type": "string"
    }
];
exports.FrameData = FrameData;
class GlobalCounterResponse {
    static getAttributeTypeMap() {
        return GlobalCounterResponse.attributeTypeMap;
    }
}
GlobalCounterResponse.discriminator = undefined;
GlobalCounterResponse.attributeTypeMap = [
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "value",
        "baseName": "value",
        "type": "number"
    }
];
exports.GlobalCounterResponse = GlobalCounterResponse;
class GroupTagData {
    static getAttributeTypeMap() {
        return GroupTagData.attributeTypeMap;
    }
}
GroupTagData.discriminator = undefined;
GroupTagData.attributeTypeMap = [
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "value",
        "baseName": "value",
        "type": "string"
    }
];
exports.GroupTagData = GroupTagData;
class HrefData {
    static getAttributeTypeMap() {
        return HrefData.attributeTypeMap;
    }
}
HrefData.discriminator = undefined;
HrefData.attributeTypeMap = [
    {
        "name": "href",
        "baseName": "href",
        "type": "string"
    }
];
exports.HrefData = HrefData;
class InsightsComponentRestBean {
    static getAttributeTypeMap() {
        return InsightsComponentRestBean.attributeTypeMap;
    }
}
InsightsComponentRestBean.discriminator = undefined;
InsightsComponentRestBean.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "id",
        "type": "number"
    },
    {
        "name": "artifact",
        "baseName": "artifact",
        "type": "string"
    },
    {
        "name": "version",
        "baseName": "version",
        "type": "string"
    },
    {
        "name": "filename",
        "baseName": "filename",
        "type": "string"
    },
    {
        "name": "language",
        "baseName": "language",
        "type": "string"
    },
    {
        "name": "obsolescenceRisk",
        "baseName": "obsolescenceRisk",
        "type": "InsightsComponentRestBean.ObsolescenceRiskEnum"
    },
    {
        "name": "licenseRisk",
        "baseName": "licenseRisk",
        "type": "InsightsComponentRestBean.LicenseRiskEnum"
    },
    {
        "name": "securityRisk",
        "baseName": "securityRisk",
        "type": "InsightsComponentRestBean.SecurityRiskEnum"
    },
    {
        "name": "sources",
        "baseName": "sources",
        "type": "Array<SourceRootSimpleRestData>"
    },
    {
        "name": "vulnerabilities",
        "baseName": "vulnerabilities",
        "type": "Array<VulnerabilityRestData>"
    }
];
exports.InsightsComponentRestBean = InsightsComponentRestBean;
(function (InsightsComponentRestBean) {
    let ObsolescenceRiskEnum;
    (function (ObsolescenceRiskEnum) {
        ObsolescenceRiskEnum[ObsolescenceRiskEnum["High"] = 'high'] = "High";
        ObsolescenceRiskEnum[ObsolescenceRiskEnum["Medium"] = 'medium'] = "Medium";
        ObsolescenceRiskEnum[ObsolescenceRiskEnum["Low"] = 'low'] = "Low";
        ObsolescenceRiskEnum[ObsolescenceRiskEnum["None"] = 'none'] = "None";
        ObsolescenceRiskEnum[ObsolescenceRiskEnum["Unknown"] = 'unknown'] = "Unknown";
    })(ObsolescenceRiskEnum = InsightsComponentRestBean.ObsolescenceRiskEnum || (InsightsComponentRestBean.ObsolescenceRiskEnum = {}));
    let LicenseRiskEnum;
    (function (LicenseRiskEnum) {
        LicenseRiskEnum[LicenseRiskEnum["High"] = 'high'] = "High";
        LicenseRiskEnum[LicenseRiskEnum["Medium"] = 'medium'] = "Medium";
        LicenseRiskEnum[LicenseRiskEnum["Low"] = 'low'] = "Low";
        LicenseRiskEnum[LicenseRiskEnum["None"] = 'none'] = "None";
        LicenseRiskEnum[LicenseRiskEnum["Unknown"] = 'unknown'] = "Unknown";
    })(LicenseRiskEnum = InsightsComponentRestBean.LicenseRiskEnum || (InsightsComponentRestBean.LicenseRiskEnum = {}));
    let SecurityRiskEnum;
    (function (SecurityRiskEnum) {
        SecurityRiskEnum[SecurityRiskEnum["High"] = 'high'] = "High";
        SecurityRiskEnum[SecurityRiskEnum["Medium"] = 'medium'] = "Medium";
        SecurityRiskEnum[SecurityRiskEnum["Low"] = 'low'] = "Low";
        SecurityRiskEnum[SecurityRiskEnum["None"] = 'none'] = "None";
        SecurityRiskEnum[SecurityRiskEnum["Unknown"] = 'unknown'] = "Unknown";
    })(SecurityRiskEnum = InsightsComponentRestBean.SecurityRiskEnum || (InsightsComponentRestBean.SecurityRiskEnum = {}));
})(InsightsComponentRestBean = exports.InsightsComponentRestBean || (exports.InsightsComponentRestBean = {}));
class LicenseRestData {
    static getAttributeTypeMap() {
        return LicenseRestData.attributeTypeMap;
    }
}
LicenseRestData.discriminator = undefined;
LicenseRestData.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "id",
        "type": "number"
    },
    {
        "name": "license",
        "baseName": "license",
        "type": "string"
    },
    {
        "name": "component",
        "baseName": "component",
        "type": "string"
    },
    {
        "name": "spdxCode",
        "baseName": "spdxCode",
        "type": "string"
    },
    {
        "name": "type",
        "baseName": "type",
        "type": "LicenseRestData.TypeEnum"
    },
    {
        "name": "url",
        "baseName": "url",
        "type": "string"
    },
    {
        "name": "risk",
        "baseName": "risk",
        "type": "LicenseRestData.RiskEnum"
    },
    {
        "name": "permissions",
        "baseName": "permissions",
        "type": "string"
    },
    {
        "name": "limitations",
        "baseName": "limitations",
        "type": "string"
    },
    {
        "name": "conditions",
        "baseName": "conditions",
        "type": "string"
    },
    {
        "name": "components",
        "baseName": "components",
        "type": "Array<ComponentSimpleRestData>"
    }
];
exports.LicenseRestData = LicenseRestData;
(function (LicenseRestData) {
    let TypeEnum;
    (function (TypeEnum) {
        TypeEnum[TypeEnum["Copyleft"] = 'Copyleft'] = "Copyleft";
        TypeEnum[TypeEnum["Copyrighted"] = 'Copyrighted'] = "Copyrighted";
        TypeEnum[TypeEnum["NonOpenSource"] = 'NonOpenSource'] = "NonOpenSource";
        TypeEnum[TypeEnum["Permissive"] = 'Permissive'] = "Permissive";
        TypeEnum[TypeEnum["Propietary"] = 'Propietary'] = "Propietary";
        TypeEnum[TypeEnum["PublicDomain"] = 'PublicDomain'] = "PublicDomain";
        TypeEnum[TypeEnum["Unknown"] = 'Unknown'] = "Unknown";
        TypeEnum[TypeEnum["WeakCopyleft"] = 'WeakCopyleft'] = "WeakCopyleft";
    })(TypeEnum = LicenseRestData.TypeEnum || (LicenseRestData.TypeEnum = {}));
    let RiskEnum;
    (function (RiskEnum) {
        RiskEnum[RiskEnum["High"] = 'High'] = "High";
        RiskEnum[RiskEnum["Medium"] = 'Medium'] = "Medium";
        RiskEnum[RiskEnum["Low"] = 'Low'] = "Low";
        RiskEnum[RiskEnum["None"] = 'None'] = "None";
        RiskEnum[RiskEnum["Unknown"] = 'Unknown'] = "Unknown";
    })(RiskEnum = LicenseRestData.RiskEnum || (LicenseRestData.RiskEnum = {}));
})(LicenseRestData = exports.LicenseRestData || (exports.LicenseRestData = {}));
/**
* It is necessary to indicate the name of the application or the analysis code
*/
class ListComponentsRequest {
    static getAttributeTypeMap() {
        return ListComponentsRequest.attributeTypeMap;
    }
}
ListComponentsRequest.discriminator = undefined;
ListComponentsRequest.attributeTypeMap = [
    {
        "name": "applicationName",
        "baseName": "applicationName",
        "type": "string"
    },
    {
        "name": "analysisCode",
        "baseName": "analysisCode",
        "type": "string"
    },
    {
        "name": "pagination",
        "baseName": "pagination",
        "type": "PaginationData"
    },
    {
        "name": "filter",
        "baseName": "filter",
        "type": "FilterData"
    }
];
exports.ListComponentsRequest = ListComponentsRequest;
class ListComponentsResponse {
    static getAttributeTypeMap() {
        return ListComponentsResponse.attributeTypeMap;
    }
}
ListComponentsResponse.discriminator = undefined;
ListComponentsResponse.attributeTypeMap = [
    {
        "name": "pagination",
        "baseName": "pagination",
        "type": "PaginationData"
    },
    {
        "name": "data",
        "baseName": "data",
        "type": "Array<ComponentDetailResponse>"
    }
];
exports.ListComponentsResponse = ListComponentsResponse;
class ListInsightsComponentsResponse {
    static getAttributeTypeMap() {
        return ListInsightsComponentsResponse.attributeTypeMap;
    }
}
ListInsightsComponentsResponse.discriminator = undefined;
ListInsightsComponentsResponse.attributeTypeMap = [
    {
        "name": "data",
        "baseName": "data",
        "type": "Array<InsightsComponentRestBean>"
    }
];
exports.ListInsightsComponentsResponse = ListInsightsComponentsResponse;
class ListLicensesResponse {
    static getAttributeTypeMap() {
        return ListLicensesResponse.attributeTypeMap;
    }
}
ListLicensesResponse.discriminator = undefined;
ListLicensesResponse.attributeTypeMap = [
    {
        "name": "data",
        "baseName": "data",
        "type": "Array<LicenseRestData>"
    }
];
exports.ListLicensesResponse = ListLicensesResponse;
class ListObsolescencesResponse {
    static getAttributeTypeMap() {
        return ListObsolescencesResponse.attributeTypeMap;
    }
}
ListObsolescencesResponse.discriminator = undefined;
ListObsolescencesResponse.attributeTypeMap = [
    {
        "name": "data",
        "baseName": "data",
        "type": "Array<ObsolescenceRestData>"
    }
];
exports.ListObsolescencesResponse = ListObsolescencesResponse;
class ListSecuritiesResponse {
    static getAttributeTypeMap() {
        return ListSecuritiesResponse.attributeTypeMap;
    }
}
ListSecuritiesResponse.discriminator = undefined;
ListSecuritiesResponse.attributeTypeMap = [
    {
        "name": "data",
        "baseName": "data",
        "type": "Array<SecurityRestData>"
    }
];
exports.ListSecuritiesResponse = ListSecuritiesResponse;
class Mapping {
    static getAttributeTypeMap() {
        return Mapping.attributeTypeMap;
    }
}
Mapping.discriminator = undefined;
Mapping.attributeTypeMap = [
    {
        "name": "mappingType",
        "baseName": "mappingType",
        "type": "Mapping.MappingTypeEnum"
    },
    {
        "name": "vendorOtherType",
        "baseName": "vendorOtherType",
        "type": "string"
    },
    {
        "name": "value",
        "baseName": "value",
        "type": "string"
    },
    {
        "name": "primary",
        "baseName": "primary",
        "type": "boolean"
    }
];
exports.Mapping = Mapping;
(function (Mapping) {
    let MappingTypeEnum;
    (function (MappingTypeEnum) {
        MappingTypeEnum[MappingTypeEnum["CWE"] = 'CWE'] = "CWE";
        MappingTypeEnum[MappingTypeEnum["CVE"] = 'CVE'] = "CVE";
        MappingTypeEnum[MappingTypeEnum["OTHER"] = 'OTHER'] = "OTHER";
        MappingTypeEnum[MappingTypeEnum["TOOLVENDOR"] = 'TOOL_VENDOR'] = "TOOLVENDOR";
    })(MappingTypeEnum = Mapping.MappingTypeEnum || (Mapping.MappingTypeEnum = {}));
})(Mapping = exports.Mapping || (exports.Mapping = {}));
class MetadataArchitectureData {
    static getAttributeTypeMap() {
        return MetadataArchitectureData.attributeTypeMap;
    }
}
MetadataArchitectureData.discriminator = undefined;
MetadataArchitectureData.attributeTypeMap = [
    {
        "name": "languages",
        "baseName": "languages",
        "type": "Array<ValueCountData>"
    },
    {
        "name": "types",
        "baseName": "types",
        "type": "Array<ValueCountData>"
    },
    {
        "name": "relations",
        "baseName": "relations",
        "type": "Array<ValueCountData>"
    },
    {
        "name": "tags",
        "baseName": "tags",
        "type": "Array<string>"
    },
    {
        "name": "groupTags",
        "baseName": "groupTags",
        "type": "{ [key: string]: Array<string>; }"
    }
];
exports.MetadataArchitectureData = MetadataArchitectureData;
class MetadataInsightsData {
    static getAttributeTypeMap() {
        return MetadataInsightsData.attributeTypeMap;
    }
}
MetadataInsightsData.discriminator = undefined;
MetadataInsightsData.attributeTypeMap = [
    {
        "name": "components",
        "baseName": "components",
        "type": "number"
    },
    {
        "name": "vulnerabilities",
        "baseName": "vulnerabilities",
        "type": "number"
    },
    {
        "name": "licenses",
        "baseName": "licenses",
        "type": "number"
    },
    {
        "name": "duplicates",
        "baseName": "duplicates",
        "type": "number"
    },
    {
        "name": "risks",
        "baseName": "risks",
        "type": "Array<MetadataInsightsRiskData>"
    }
];
exports.MetadataInsightsData = MetadataInsightsData;
class MetadataInsightsRiskData {
    static getAttributeTypeMap() {
        return MetadataInsightsRiskData.attributeTypeMap;
    }
}
MetadataInsightsRiskData.discriminator = undefined;
MetadataInsightsRiskData.attributeTypeMap = [
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "risk",
        "baseName": "risk",
        "type": "{ [key: string]: number; }"
    }
];
exports.MetadataInsightsRiskData = MetadataInsightsRiskData;
class MetricValueData {
    static getAttributeTypeMap() {
        return MetricValueData.attributeTypeMap;
    }
}
MetricValueData.discriminator = undefined;
MetricValueData.attributeTypeMap = [
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "size",
        "baseName": "size",
        "type": "number"
    }
];
exports.MetricValueData = MetricValueData;
class NavigationFilterData {
    static getAttributeTypeMap() {
        return NavigationFilterData.attributeTypeMap;
    }
}
NavigationFilterData.discriminator = undefined;
NavigationFilterData.attributeTypeMap = [
    {
        "name": "relations",
        "baseName": "relations",
        "type": "string"
    },
    {
        "name": "direction",
        "baseName": "direction",
        "type": "NavigationFilterData.DirectionEnum"
    },
    {
        "name": "depth",
        "baseName": "depth",
        "type": "number"
    }
];
exports.NavigationFilterData = NavigationFilterData;
(function (NavigationFilterData) {
    let DirectionEnum;
    (function (DirectionEnum) {
        DirectionEnum[DirectionEnum["In"] = 'in'] = "In";
        DirectionEnum[DirectionEnum["Out"] = 'out'] = "Out";
        DirectionEnum[DirectionEnum["Any"] = 'any'] = "Any";
    })(DirectionEnum = NavigationFilterData.DirectionEnum || (NavigationFilterData.DirectionEnum = {}));
})(NavigationFilterData = exports.NavigationFilterData || (exports.NavigationFilterData = {}));
class ObsolescenceRestData {
    static getAttributeTypeMap() {
        return ObsolescenceRestData.attributeTypeMap;
    }
}
ObsolescenceRestData.discriminator = undefined;
ObsolescenceRestData.attributeTypeMap = [
    {
        "name": "component",
        "baseName": "component",
        "type": "string"
    },
    {
        "name": "language",
        "baseName": "language",
        "type": "string"
    },
    {
        "name": "usedVersion",
        "baseName": "usedVersion",
        "type": "string"
    },
    {
        "name": "dateUsed",
        "baseName": "dateUsed",
        "type": "string"
    },
    {
        "name": "lastVersion",
        "baseName": "lastVersion",
        "type": "string"
    },
    {
        "name": "dateLast",
        "baseName": "dateLast",
        "type": "string"
    },
    {
        "name": "release",
        "baseName": "release",
        "type": "string"
    },
    {
        "name": "outOfDate",
        "baseName": "outOfDate",
        "type": "string"
    },
    {
        "name": "timeInactivity",
        "baseName": "timeInactivity",
        "type": "string"
    },
    {
        "name": "obsolescenceRisk",
        "baseName": "obsolescenceRisk",
        "type": "string"
    },
    {
        "name": "risk",
        "baseName": "risk",
        "type": "ObsolescenceRestData.RiskEnum"
    },
    {
        "name": "description",
        "baseName": "description",
        "type": "string"
    }
];
exports.ObsolescenceRestData = ObsolescenceRestData;
(function (ObsolescenceRestData) {
    let RiskEnum;
    (function (RiskEnum) {
        RiskEnum[RiskEnum["High"] = 'High'] = "High";
        RiskEnum[RiskEnum["Medium"] = 'Medium'] = "Medium";
        RiskEnum[RiskEnum["Low"] = 'Low'] = "Low";
    })(RiskEnum = ObsolescenceRestData.RiskEnum || (ObsolescenceRestData.RiskEnum = {}));
})(ObsolescenceRestData = exports.ObsolescenceRestData || (exports.ObsolescenceRestData = {}));
class PaginationData {
    static getAttributeTypeMap() {
        return PaginationData.attributeTypeMap;
    }
}
PaginationData.discriminator = undefined;
PaginationData.attributeTypeMap = [
    {
        "name": "page",
        "baseName": "page",
        "type": "number"
    },
    {
        "name": "count",
        "baseName": "count",
        "type": "number"
    },
    {
        "name": "total",
        "baseName": "total",
        "type": "number"
    }
];
exports.PaginationData = PaginationData;
class PortfolioData {
    static getAttributeTypeMap() {
        return PortfolioData.attributeTypeMap;
    }
}
PortfolioData.discriminator = undefined;
PortfolioData.attributeTypeMap = [
    {
        "name": "portfolioName",
        "baseName": "portfolioName",
        "type": "string"
    },
    {
        "name": "portfolioValue",
        "baseName": "portfolioValue",
        "type": "string"
    }
];
exports.PortfolioData = PortfolioData;
class PortfolioDefinitionData {
    static getAttributeTypeMap() {
        return PortfolioDefinitionData.attributeTypeMap;
    }
}
PortfolioDefinitionData.discriminator = undefined;
PortfolioDefinitionData.attributeTypeMap = [
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "description",
        "baseName": "description",
        "type": "string"
    },
    {
        "name": "isSystemPortfolio",
        "baseName": "isSystemPortfolio",
        "type": "boolean"
    },
    {
        "name": "values",
        "baseName": "values",
        "type": "Array<string>"
    }
];
exports.PortfolioDefinitionData = PortfolioDefinitionData;
class PortfolioRoleData {
    static getAttributeTypeMap() {
        return PortfolioRoleData.attributeTypeMap;
    }
}
PortfolioRoleData.discriminator = undefined;
PortfolioRoleData.attributeTypeMap = [
    {
        "name": "type",
        "baseName": "type",
        "type": "PortfolioRoleData.TypeEnum"
    },
    {
        "name": "portfolioName",
        "baseName": "portfolioName",
        "type": "string"
    },
    {
        "name": "portfolioValue",
        "baseName": "portfolioValue",
        "type": "string"
    },
    {
        "name": "roleName",
        "baseName": "roleName",
        "type": "string"
    }
];
exports.PortfolioRoleData = PortfolioRoleData;
(function (PortfolioRoleData) {
    let TypeEnum;
    (function (TypeEnum) {
        TypeEnum[TypeEnum["CUSTOM"] = 'CUSTOM'] = "CUSTOM";
        TypeEnum[TypeEnum["SYSTEM"] = 'SYSTEM'] = "SYSTEM";
    })(TypeEnum = PortfolioRoleData.TypeEnum || (PortfolioRoleData.TypeEnum = {}));
})(PortfolioRoleData = exports.PortfolioRoleData || (exports.PortfolioRoleData = {}));
class ProviderPortfolioRoleData {
    static getAttributeTypeMap() {
        return ProviderPortfolioRoleData.attributeTypeMap;
    }
}
ProviderPortfolioRoleData.discriminator = undefined;
ProviderPortfolioRoleData.attributeTypeMap = [
    {
        "name": "type",
        "baseName": "type",
        "type": "ProviderPortfolioRoleData.TypeEnum"
    },
    {
        "name": "portfolioValue",
        "baseName": "portfolioValue",
        "type": "string"
    },
    {
        "name": "roleName",
        "baseName": "roleName",
        "type": "string"
    }
];
exports.ProviderPortfolioRoleData = ProviderPortfolioRoleData;
(function (ProviderPortfolioRoleData) {
    let TypeEnum;
    (function (TypeEnum) {
        TypeEnum[TypeEnum["SYSTEM"] = 'SYSTEM'] = "SYSTEM";
    })(TypeEnum = ProviderPortfolioRoleData.TypeEnum || (ProviderPortfolioRoleData.TypeEnum = {}));
})(ProviderPortfolioRoleData = exports.ProviderPortfolioRoleData || (exports.ProviderPortfolioRoleData = {}));
class RelationRestData {
    static getAttributeTypeMap() {
        return RelationRestData.attributeTypeMap;
    }
}
RelationRestData.discriminator = undefined;
RelationRestData.attributeTypeMap = [
    {
        "name": "source",
        "baseName": "source",
        "type": "number"
    },
    {
        "name": "target",
        "baseName": "target",
        "type": "number"
    },
    {
        "name": "type",
        "baseName": "type",
        "type": "string"
    }
];
exports.RelationRestData = RelationRestData;
class RuleDocumentationResponse {
    static getAttributeTypeMap() {
        return RuleDocumentationResponse.attributeTypeMap;
    }
}
RuleDocumentationResponse.discriminator = undefined;
RuleDocumentationResponse.attributeTypeMap = [
    {
        "name": "description",
        "baseName": "description",
        "type": "string"
    },
    {
        "name": "code",
        "baseName": "code",
        "type": "string"
    },
    {
        "name": "references",
        "baseName": "references",
        "type": "string"
    },
    {
        "name": "benefits",
        "baseName": "benefits",
        "type": "string"
    },
    {
        "name": "drawbacks",
        "baseName": "drawbacks",
        "type": "string"
    },
    {
        "name": "violationCode",
        "baseName": "violationCode",
        "type": "string"
    },
    {
        "name": "fixedCode",
        "baseName": "fixedCode",
        "type": "string"
    },
    {
        "name": "tags",
        "baseName": "tags",
        "type": "Array<string>"
    },
    {
        "name": "normatives",
        "baseName": "normatives",
        "type": "Array<string>"
    }
];
exports.RuleDocumentationResponse = RuleDocumentationResponse;
class Scan {
    static getAttributeTypeMap() {
        return Scan.attributeTypeMap;
    }
}
Scan.discriminator = undefined;
Scan.attributeTypeMap = [
    {
        "name": "collectionType",
        "baseName": "collectionType",
        "type": "string"
    },
    {
        "name": "created",
        "baseName": "created",
        "type": "string"
    },
    {
        "name": "exported",
        "baseName": "exported",
        "type": "string"
    },
    {
        "name": "source",
        "baseName": "source",
        "type": "string"
    },
    {
        "name": "findings",
        "baseName": "findings",
        "type": "Array<Finding>"
    },
    {
        "name": "metadata",
        "baseName": "metadata",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "executiveSummary",
        "baseName": "executiveSummary",
        "type": "string"
    }
];
exports.Scan = Scan;
class SearchImpactResponse {
    static getAttributeTypeMap() {
        return SearchImpactResponse.attributeTypeMap;
    }
}
SearchImpactResponse.discriminator = undefined;
SearchImpactResponse.attributeTypeMap = [
    {
        "name": "pagination",
        "baseName": "pagination",
        "type": "PaginationData"
    },
    {
        "name": "data",
        "baseName": "data",
        "type": "Array<ComponentDetailResponse>"
    },
    {
        "name": "analysisImpactCode",
        "baseName": "analysisImpactCode",
        "type": "string"
    }
];
exports.SearchImpactResponse = SearchImpactResponse;
/**
* It is mandatory at least one of the following parameters, application name, analysis code or analysis impact code. If you have already indicated the analysis impact code, the navigation filter is not necessary, in other cases it is. Indicating the pagination filter is necessary in any case.
*/
class SearchSourcesImpactRequest {
    static getAttributeTypeMap() {
        return SearchSourcesImpactRequest.attributeTypeMap;
    }
}
SearchSourcesImpactRequest.discriminator = undefined;
SearchSourcesImpactRequest.attributeTypeMap = [
    {
        "name": "applicationName",
        "baseName": "applicationName",
        "type": "string"
    },
    {
        "name": "analysisCode",
        "baseName": "analysisCode",
        "type": "string"
    },
    {
        "name": "analysisImpactCode",
        "baseName": "analysisImpactCode",
        "type": "string"
    },
    {
        "name": "sourceFilter",
        "baseName": "sourceFilter",
        "type": "FilterData"
    },
    {
        "name": "sourceIds",
        "baseName": "sourceIds",
        "type": "Array<number>"
    },
    {
        "name": "targetId",
        "baseName": "targetId",
        "type": "number"
    },
    {
        "name": "navigationFilter",
        "baseName": "navigationFilter",
        "type": "NavigationFilterData"
    },
    {
        "name": "pagination",
        "baseName": "pagination",
        "type": "PaginationData"
    }
];
exports.SearchSourcesImpactRequest = SearchSourcesImpactRequest;
/**
* It is mandatory at least one of the following parameters, application name, analysis code or analysis impact code. If you have already indicated the analysis impact code, the navigation filter is not necessary, in other cases it is. Indicating the pagination filter is necessary in any case.
*/
class SearchTargetsImpactRequest {
    static getAttributeTypeMap() {
        return SearchTargetsImpactRequest.attributeTypeMap;
    }
}
SearchTargetsImpactRequest.discriminator = undefined;
SearchTargetsImpactRequest.attributeTypeMap = [
    {
        "name": "applicationName",
        "baseName": "applicationName",
        "type": "string"
    },
    {
        "name": "analysisCode",
        "baseName": "analysisCode",
        "type": "string"
    },
    {
        "name": "analysisImpactCode",
        "baseName": "analysisImpactCode",
        "type": "string"
    },
    {
        "name": "sourceFilter",
        "baseName": "sourceFilter",
        "type": "FilterData"
    },
    {
        "name": "targetFilter",
        "baseName": "targetFilter",
        "type": "FilterData"
    },
    {
        "name": "sourceIds",
        "baseName": "sourceIds",
        "type": "Array<number>"
    },
    {
        "name": "targetIds",
        "baseName": "targetIds",
        "type": "Array<number>"
    },
    {
        "name": "navigationFilter",
        "baseName": "navigationFilter",
        "type": "NavigationFilterData"
    },
    {
        "name": "pagination",
        "baseName": "pagination",
        "type": "PaginationData"
    }
];
exports.SearchTargetsImpactRequest = SearchTargetsImpactRequest;
class SecurityRestData {
    static getAttributeTypeMap() {
        return SecurityRestData.attributeTypeMap;
    }
}
SecurityRestData.discriminator = undefined;
SecurityRestData.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "id",
        "type": "number"
    },
    {
        "name": "cve",
        "baseName": "cve",
        "type": "string"
    },
    {
        "name": "cwe",
        "baseName": "cwe",
        "type": "string"
    },
    {
        "name": "lastModified",
        "baseName": "lastModified",
        "type": "string"
    },
    {
        "name": "exploitabilitySubscore",
        "baseName": "exploitabilitySubscore",
        "type": "string"
    },
    {
        "name": "impactSubscore",
        "baseName": "impactSubscore",
        "type": "string"
    },
    {
        "name": "getcVSSv2BaseScore",
        "baseName": "getcVSSv2BaseScore",
        "type": "string"
    },
    {
        "name": "securityRisk",
        "baseName": "securityRisk",
        "type": "string"
    },
    {
        "name": "description",
        "baseName": "description",
        "type": "string"
    },
    {
        "name": "components",
        "baseName": "components",
        "type": "Array<ComponentSimpleRestData>"
    }
];
exports.SecurityRestData = SecurityRestData;
class SourceChildSimpleRestData {
    static getAttributeTypeMap() {
        return SourceChildSimpleRestData.attributeTypeMap;
    }
}
SourceChildSimpleRestData.discriminator = undefined;
SourceChildSimpleRestData.attributeTypeMap = [
    {
        "name": "repository",
        "baseName": "repository",
        "type": "string"
    },
    {
        "name": "artifact",
        "baseName": "artifact",
        "type": "string"
    },
    {
        "name": "version",
        "baseName": "version",
        "type": "string"
    },
    {
        "name": "child",
        "baseName": "child",
        "type": "Array<SourceChildSimpleRestData>"
    }
];
exports.SourceChildSimpleRestData = SourceChildSimpleRestData;
class SourceRootSimpleRestData {
    static getAttributeTypeMap() {
        return SourceRootSimpleRestData.attributeTypeMap;
    }
}
SourceRootSimpleRestData.discriminator = undefined;
SourceRootSimpleRestData.attributeTypeMap = [
    {
        "name": "path",
        "baseName": "path",
        "type": "string"
    },
    {
        "name": "artifact",
        "baseName": "artifact",
        "type": "string"
    },
    {
        "name": "version",
        "baseName": "version",
        "type": "string"
    },
    {
        "name": "child",
        "baseName": "child",
        "type": "Array<SourceChildSimpleRestData>"
    }
];
exports.SourceRootSimpleRestData = SourceRootSimpleRestData;
class StaticDetails {
    static getAttributeTypeMap() {
        return StaticDetails.attributeTypeMap;
    }
}
StaticDetails.discriminator = undefined;
StaticDetails.attributeTypeMap = [
    {
        "name": "dataFlow",
        "baseName": "dataFlow",
        "type": "Array<DataFlowElement>"
    },
    {
        "name": "parameter",
        "baseName": "parameter",
        "type": "string"
    }
];
exports.StaticDetails = StaticDetails;
/**
* It is necessary to indicate the name of the application or the analysis code, as well as the source and the target identifier
*/
class SubGraphImpactRequest {
    static getAttributeTypeMap() {
        return SubGraphImpactRequest.attributeTypeMap;
    }
}
SubGraphImpactRequest.discriminator = undefined;
SubGraphImpactRequest.attributeTypeMap = [
    {
        "name": "applicationName",
        "baseName": "applicationName",
        "type": "string"
    },
    {
        "name": "analysisCode",
        "baseName": "analysisCode",
        "type": "string"
    },
    {
        "name": "sourceId",
        "baseName": "sourceId",
        "type": "number"
    },
    {
        "name": "targetId",
        "baseName": "targetId",
        "type": "number"
    },
    {
        "name": "navigationFilter",
        "baseName": "navigationFilter",
        "type": "NavigationFilterData"
    }
];
exports.SubGraphImpactRequest = SubGraphImpactRequest;
class SubGraphImpactResponse {
    static getAttributeTypeMap() {
        return SubGraphImpactResponse.attributeTypeMap;
    }
}
SubGraphImpactResponse.discriminator = undefined;
SubGraphImpactResponse.attributeTypeMap = [
    {
        "name": "components",
        "baseName": "components",
        "type": "Array<ComponentDetailResponse>"
    },
    {
        "name": "relations",
        "baseName": "relations",
        "type": "Array<RelationRestData>"
    }
];
exports.SubGraphImpactResponse = SubGraphImpactResponse;
class UnparsedFileData {
    static getAttributeTypeMap() {
        return UnparsedFileData.attributeTypeMap;
    }
}
UnparsedFileData.discriminator = undefined;
UnparsedFileData.attributeTypeMap = [
    {
        "name": "file",
        "baseName": "file",
        "type": "string"
    },
    {
        "name": "cause",
        "baseName": "cause",
        "type": "string"
    }
];
exports.UnparsedFileData = UnparsedFileData;
class UserApplicationRoleResponse {
    static getAttributeTypeMap() {
        return UserApplicationRoleResponse.attributeTypeMap;
    }
}
UserApplicationRoleResponse.discriminator = undefined;
UserApplicationRoleResponse.attributeTypeMap = [
    {
        "name": "username",
        "baseName": "username",
        "type": "string"
    },
    {
        "name": "roleName",
        "baseName": "roleName",
        "type": "string"
    },
    {
        "name": "override",
        "baseName": "override",
        "type": "boolean"
    }
];
exports.UserApplicationRoleResponse = UserApplicationRoleResponse;
class UserAppsPermissionsResponse {
    static getAttributeTypeMap() {
        return UserAppsPermissionsResponse.attributeTypeMap;
    }
}
UserAppsPermissionsResponse.discriminator = undefined;
UserAppsPermissionsResponse.attributeTypeMap = [
    {
        "name": "username",
        "baseName": "username",
        "type": "string"
    },
    {
        "name": "email",
        "baseName": "email",
        "type": "string"
    },
    {
        "name": "firstName",
        "baseName": "firstName",
        "type": "string"
    },
    {
        "name": "lastName",
        "baseName": "lastName",
        "type": "string"
    },
    {
        "name": "managementFeatures",
        "baseName": "managementFeatures",
        "type": "Array<string>"
    },
    {
        "name": "enabled",
        "baseName": "enabled",
        "type": "boolean"
    },
    {
        "name": "supportEnabled",
        "baseName": "supportEnabled",
        "type": "boolean"
    },
    {
        "name": "overrideUserGroup",
        "baseName": "overrideUserGroup",
        "type": "boolean"
    },
    {
        "name": "manageApplications",
        "baseName": "manageApplications",
        "type": "boolean"
    },
    {
        "name": "manageUsers",
        "baseName": "manageUsers",
        "type": "boolean"
    },
    {
        "name": "manageModels",
        "baseName": "manageModels",
        "type": "boolean"
    },
    {
        "name": "manageAudits",
        "baseName": "manageAudits",
        "type": "boolean"
    },
    {
        "name": "manageReports",
        "baseName": "manageReports",
        "type": "boolean"
    },
    {
        "name": "applicationPermissionsData",
        "baseName": "applicationPermissionsData",
        "type": "Array<ApplicationPermissionsData>"
    }
];
exports.UserAppsPermissionsResponse = UserAppsPermissionsResponse;
class UserDetailResponse {
    static getAttributeTypeMap() {
        return UserDetailResponse.attributeTypeMap;
    }
}
UserDetailResponse.discriminator = undefined;
UserDetailResponse.attributeTypeMap = [
    {
        "name": "username",
        "baseName": "username",
        "type": "string"
    },
    {
        "name": "firstName",
        "baseName": "firstName",
        "type": "string"
    },
    {
        "name": "lastName",
        "baseName": "lastName",
        "type": "string"
    },
    {
        "name": "enabled",
        "baseName": "enabled",
        "type": "boolean"
    },
    {
        "name": "email",
        "baseName": "email",
        "type": "string"
    },
    {
        "name": "isOwner",
        "baseName": "isOwner",
        "type": "boolean"
    },
    {
        "name": "enableLoginWithPassword",
        "baseName": "enableLoginWithPassword",
        "type": "boolean"
    }
];
exports.UserDetailResponse = UserDetailResponse;
class UserGroupRequest {
    static getAttributeTypeMap() {
        return UserGroupRequest.attributeTypeMap;
    }
}
UserGroupRequest.discriminator = undefined;
UserGroupRequest.attributeTypeMap = [
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "newName",
        "baseName": "newName",
        "type": "string"
    },
    {
        "name": "users",
        "baseName": "users",
        "type": "Array<string>"
    },
    {
        "name": "accessControlConfiguration",
        "baseName": "accessControlConfiguration",
        "type": "AccessControlConfigurationData"
    }
];
exports.UserGroupRequest = UserGroupRequest;
class UserGroupResponse {
    static getAttributeTypeMap() {
        return UserGroupResponse.attributeTypeMap;
    }
}
UserGroupResponse.discriminator = undefined;
UserGroupResponse.attributeTypeMap = [
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "users",
        "baseName": "users",
        "type": "Array<string>"
    }
];
exports.UserGroupResponse = UserGroupResponse;
class UserInformationResponse {
    static getAttributeTypeMap() {
        return UserInformationResponse.attributeTypeMap;
    }
}
UserInformationResponse.discriminator = undefined;
UserInformationResponse.attributeTypeMap = [
    {
        "name": "username",
        "baseName": "username",
        "type": "string"
    },
    {
        "name": "organization",
        "baseName": "organization",
        "type": "string"
    }
];
exports.UserInformationResponse = UserInformationResponse;
class UserManagementRequest {
    static getAttributeTypeMap() {
        return UserManagementRequest.attributeTypeMap;
    }
}
UserManagementRequest.discriminator = undefined;
UserManagementRequest.attributeTypeMap = [
    {
        "name": "username",
        "baseName": "username",
        "type": "string"
    },
    {
        "name": "firstName",
        "baseName": "firstName",
        "type": "string"
    },
    {
        "name": "lastName",
        "baseName": "lastName",
        "type": "string"
    },
    {
        "name": "enabled",
        "baseName": "enabled",
        "type": "boolean"
    },
    {
        "name": "email",
        "baseName": "email",
        "type": "string"
    },
    {
        "name": "generatePassword",
        "baseName": "generatePassword",
        "type": "boolean"
    },
    {
        "name": "regeneratePassword",
        "baseName": "regeneratePassword",
        "type": "boolean"
    },
    {
        "name": "enableLoginWithPassword",
        "baseName": "enableLoginWithPassword",
        "type": "boolean"
    },
    {
        "name": "accessControlConfiguration",
        "baseName": "accessControlConfiguration",
        "type": "AccessControlConfigurationData"
    }
];
exports.UserManagementRequest = UserManagementRequest;
class UserPortfolioRoleData {
    static getAttributeTypeMap() {
        return UserPortfolioRoleData.attributeTypeMap;
    }
}
UserPortfolioRoleData.discriminator = undefined;
UserPortfolioRoleData.attributeTypeMap = [
    {
        "name": "type",
        "baseName": "type",
        "type": "UserPortfolioRoleData.TypeEnum"
    },
    {
        "name": "username",
        "baseName": "username",
        "type": "string"
    },
    {
        "name": "portfolioValue",
        "baseName": "portfolioValue",
        "type": "string"
    },
    {
        "name": "roleName",
        "baseName": "roleName",
        "type": "string"
    }
];
exports.UserPortfolioRoleData = UserPortfolioRoleData;
(function (UserPortfolioRoleData) {
    let TypeEnum;
    (function (TypeEnum) {
        TypeEnum[TypeEnum["CUSTOM"] = 'CUSTOM'] = "CUSTOM";
        TypeEnum[TypeEnum["SYSTEM"] = 'SYSTEM'] = "SYSTEM";
    })(TypeEnum = UserPortfolioRoleData.TypeEnum || (UserPortfolioRoleData.TypeEnum = {}));
})(UserPortfolioRoleData = exports.UserPortfolioRoleData || (exports.UserPortfolioRoleData = {}));
class ValueCountData {
    static getAttributeTypeMap() {
        return ValueCountData.attributeTypeMap;
    }
}
ValueCountData.discriminator = undefined;
ValueCountData.attributeTypeMap = [
    {
        "name": "value",
        "baseName": "value",
        "type": "string"
    },
    {
        "name": "count",
        "baseName": "count",
        "type": "number"
    }
];
exports.ValueCountData = ValueCountData;
class ViolatedRuleResponse {
    static getAttributeTypeMap() {
        return ViolatedRuleResponse.attributeTypeMap;
    }
}
ViolatedRuleResponse.discriminator = undefined;
ViolatedRuleResponse.attributeTypeMap = [
    {
        "name": "ruleCode",
        "baseName": "ruleCode",
        "type": "string"
    },
    {
        "name": "modelId",
        "baseName": "modelId",
        "type": "number"
    },
    {
        "name": "defectsCount",
        "baseName": "defectsCount",
        "type": "number"
    },
    {
        "name": "suppressedDefectsCount",
        "baseName": "suppressedDefectsCount",
        "type": "number"
    },
    {
        "name": "filesCount",
        "baseName": "filesCount",
        "type": "number"
    },
    {
        "name": "effort",
        "baseName": "effort",
        "type": "string"
    },
    {
        "name": "characteristic",
        "baseName": "characteristic",
        "type": "ViolatedRuleResponse.CharacteristicEnum"
    },
    {
        "name": "vulnerabilityType",
        "baseName": "vulnerabilityType",
        "type": "string"
    },
    {
        "name": "tags",
        "baseName": "tags",
        "type": "Array<string>"
    },
    {
        "name": "priority",
        "baseName": "priority",
        "type": "ViolatedRuleResponse.PriorityEnum"
    },
    {
        "name": "language",
        "baseName": "language",
        "type": "string"
    },
    {
        "name": "files",
        "baseName": "files",
        "type": "HrefData"
    }
];
exports.ViolatedRuleResponse = ViolatedRuleResponse;
(function (ViolatedRuleResponse) {
    let CharacteristicEnum;
    (function (CharacteristicEnum) {
        CharacteristicEnum[CharacteristicEnum["Efficiency"] = 'Efficiency'] = "Efficiency";
        CharacteristicEnum[CharacteristicEnum["Maintainability"] = 'Maintainability'] = "Maintainability";
        CharacteristicEnum[CharacteristicEnum["Portability"] = 'Portability'] = "Portability";
        CharacteristicEnum[CharacteristicEnum["Reliability"] = 'Reliability'] = "Reliability";
        CharacteristicEnum[CharacteristicEnum["Security"] = 'Security'] = "Security";
    })(CharacteristicEnum = ViolatedRuleResponse.CharacteristicEnum || (ViolatedRuleResponse.CharacteristicEnum = {}));
    let PriorityEnum;
    (function (PriorityEnum) {
        PriorityEnum[PriorityEnum["VeryLow"] = 'Very Low'] = "VeryLow";
        PriorityEnum[PriorityEnum["Low"] = 'Low'] = "Low";
        PriorityEnum[PriorityEnum["Normal"] = 'Normal'] = "Normal";
        PriorityEnum[PriorityEnum["High"] = 'High'] = "High";
        PriorityEnum[PriorityEnum["VeryHigh"] = 'Very High'] = "VeryHigh";
    })(PriorityEnum = ViolatedRuleResponse.PriorityEnum || (ViolatedRuleResponse.PriorityEnum = {}));
})(ViolatedRuleResponse = exports.ViolatedRuleResponse || (exports.ViolatedRuleResponse = {}));
class VulnerabilityData {
    static getAttributeTypeMap() {
        return VulnerabilityData.attributeTypeMap;
    }
}
VulnerabilityData.discriminator = undefined;
VulnerabilityData.attributeTypeMap = [
    {
        "name": "cweId",
        "baseName": "cweId",
        "type": "number"
    },
    {
        "name": "category",
        "baseName": "category",
        "type": "string"
    },
    {
        "name": "resource",
        "baseName": "resource",
        "type": "string"
    },
    {
        "name": "container",
        "baseName": "container",
        "type": "string"
    },
    {
        "name": "injectionPoint",
        "baseName": "injectionPoint",
        "type": "string"
    },
    {
        "name": "variableDeclaration",
        "baseName": "variableDeclaration",
        "type": "string"
    },
    {
        "name": "sourceFile",
        "baseName": "sourceFile",
        "type": "string"
    },
    {
        "name": "sourceLine",
        "baseName": "sourceLine",
        "type": "number"
    },
    {
        "name": "sourceCode",
        "baseName": "sourceCode",
        "type": "string"
    },
    {
        "name": "sourceCategory",
        "baseName": "sourceCategory",
        "type": "string"
    },
    {
        "name": "sourceResource",
        "baseName": "sourceResource",
        "type": "string"
    },
    {
        "name": "sourceContainer",
        "baseName": "sourceContainer",
        "type": "string"
    },
    {
        "name": "sourceInjectionPoint",
        "baseName": "sourceInjectionPoint",
        "type": "string"
    },
    {
        "name": "frames",
        "baseName": "frames",
        "type": "Array<FrameData>"
    },
    {
        "name": "datapaths",
        "baseName": "datapaths",
        "type": "Array<DatapathData>"
    }
];
exports.VulnerabilityData = VulnerabilityData;
class VulnerabilityRestData {
    static getAttributeTypeMap() {
        return VulnerabilityRestData.attributeTypeMap;
    }
}
VulnerabilityRestData.discriminator = undefined;
VulnerabilityRestData.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "id",
        "type": "number"
    },
    {
        "name": "cve",
        "baseName": "cve",
        "type": "string"
    },
    {
        "name": "cwe",
        "baseName": "cwe",
        "type": "string"
    },
    {
        "name": "description",
        "baseName": "description",
        "type": "string"
    },
    {
        "name": "severity",
        "baseName": "severity",
        "type": "VulnerabilityRestData.SeverityEnum"
    }
];
exports.VulnerabilityRestData = VulnerabilityRestData;
(function (VulnerabilityRestData) {
    let SeverityEnum;
    (function (SeverityEnum) {
        SeverityEnum[SeverityEnum["High"] = 'High'] = "High";
        SeverityEnum[SeverityEnum["Medium"] = 'Medium'] = "Medium";
        SeverityEnum[SeverityEnum["Low"] = 'Low'] = "Low";
    })(SeverityEnum = VulnerabilityRestData.SeverityEnum || (VulnerabilityRestData.SeverityEnum = {}));
})(VulnerabilityRestData = exports.VulnerabilityRestData || (exports.VulnerabilityRestData = {}));
let enumsMap = {
    "AccessControlConfigurationData.AssignmentModeEnum": AccessControlConfigurationData.AssignmentModeEnum,
    "AnalysisDefectsResponse.ApplicationBusinessValueEnum": AnalysisDefectsResponse.ApplicationBusinessValueEnum,
    "AnalysisDefectsResponse.AnalysisBusinessValueEnum": AnalysisDefectsResponse.AnalysisBusinessValueEnum,
    "AnalysisDefectsResponse.AnalysisStatusEnum": AnalysisDefectsResponse.AnalysisStatusEnum,
    "AnalysisFilesResponse.ApplicationBusinessValueEnum": AnalysisFilesResponse.ApplicationBusinessValueEnum,
    "AnalysisFilesResponse.AnalysisBusinessValueEnum": AnalysisFilesResponse.AnalysisBusinessValueEnum,
    "AnalysisFilesResponse.AnalysisStatusEnum": AnalysisFilesResponse.AnalysisStatusEnum,
    "AnalysisResponse.StatusEnum": AnalysisResponse.StatusEnum,
    "AnalysisResponse.AnalysisScopeEnum": AnalysisResponse.AnalysisScopeEnum,
    "AnalysisResponse.ChangeRequestStatusEnum": AnalysisResponse.ChangeRequestStatusEnum,
    "AnalysisResponse.AnalysisBusinessValueEnum": AnalysisResponse.AnalysisBusinessValueEnum,
    "AnalysisResultResponse.ApplicationBusinessValueEnum": AnalysisResultResponse.ApplicationBusinessValueEnum,
    "AnalysisResultResponse.AnalysisBusinessValueEnum": AnalysisResultResponse.AnalysisBusinessValueEnum,
    "AnalysisResultResponse.AnalysisStatusEnum": AnalysisResultResponse.AnalysisStatusEnum,
    "AnalysisResultResponse.AnalysisScopeEnum": AnalysisResultResponse.AnalysisScopeEnum,
    "AnalysisResultResponse.ChangeRequestStatusEnum": AnalysisResultResponse.ChangeRequestStatusEnum,
    "ApplicationAnalysisResponse.ApplicationBusinessValueEnum": ApplicationAnalysisResponse.ApplicationBusinessValueEnum,
    "ApplicationAnalysisResponse.AnalysisBusinessValueEnum": ApplicationAnalysisResponse.AnalysisBusinessValueEnum,
    "ApplicationAnalysisResponse.AnalysisStatusEnum": ApplicationAnalysisResponse.AnalysisStatusEnum,
    "ApplicationManagementRequest.BusinessValueEnum": ApplicationManagementRequest.BusinessValueEnum,
    "ApplicationResponse.ApplicationBusinessValueEnum": ApplicationResponse.ApplicationBusinessValueEnum,
    "AuditAnalysisResultResponse.OverallResultEnum": AuditAnalysisResultResponse.OverallResultEnum,
    "BusinessValuePortfolioRoleData.TypeEnum": BusinessValuePortfolioRoleData.TypeEnum,
    "CheckpointResultData.ResultEnum": CheckpointResultData.ResultEnum,
    "DatapathData.KindEnum": DatapathData.KindEnum,
    "DefectDetailResponse.StatusEnum": DefectDetailResponse.StatusEnum,
    "DefectDetailResponse.CharacteristicEnum": DefectDetailResponse.CharacteristicEnum,
    "DefectDetailResponse.PriorityEnum": DefectDetailResponse.PriorityEnum,
    "Finding.SeverityEnum": Finding.SeverityEnum,
    "InsightsComponentRestBean.ObsolescenceRiskEnum": InsightsComponentRestBean.ObsolescenceRiskEnum,
    "InsightsComponentRestBean.LicenseRiskEnum": InsightsComponentRestBean.LicenseRiskEnum,
    "InsightsComponentRestBean.SecurityRiskEnum": InsightsComponentRestBean.SecurityRiskEnum,
    "LicenseRestData.TypeEnum": LicenseRestData.TypeEnum,
    "LicenseRestData.RiskEnum": LicenseRestData.RiskEnum,
    "Mapping.MappingTypeEnum": Mapping.MappingTypeEnum,
    "NavigationFilterData.DirectionEnum": NavigationFilterData.DirectionEnum,
    "ObsolescenceRestData.RiskEnum": ObsolescenceRestData.RiskEnum,
    "PortfolioRoleData.TypeEnum": PortfolioRoleData.TypeEnum,
    "ProviderPortfolioRoleData.TypeEnum": ProviderPortfolioRoleData.TypeEnum,
    "UserPortfolioRoleData.TypeEnum": UserPortfolioRoleData.TypeEnum,
    "ViolatedRuleResponse.CharacteristicEnum": ViolatedRuleResponse.CharacteristicEnum,
    "ViolatedRuleResponse.PriorityEnum": ViolatedRuleResponse.PriorityEnum,
    "VulnerabilityRestData.SeverityEnum": VulnerabilityRestData.SeverityEnum,
};
let typeMap = {
    "AccessControlConfigurationData": AccessControlConfigurationData,
    "ActionPlanDefectsResponse": ActionPlanDefectsResponse,
    "ActionPlanDetailResponse": ActionPlanDetailResponse,
    "ActionPlanPendingDefectsResponse": ActionPlanPendingDefectsResponse,
    "ActionPlanProgressResponse": ActionPlanProgressResponse,
    "ActionPlanRemovedDefectsResponse": ActionPlanRemovedDefectsResponse,
    "AnalysisDefectsResponse": AnalysisDefectsResponse,
    "AnalysisFilesResponse": AnalysisFilesResponse,
    "AnalysisResponse": AnalysisResponse,
    "AnalysisResultResponse": AnalysisResultResponse,
    "ApplicationAnalysisResponse": ApplicationAnalysisResponse,
    "ApplicationManagementRequest": ApplicationManagementRequest,
    "ApplicationPermissionsData": ApplicationPermissionsData,
    "ApplicationResponse": ApplicationResponse,
    "ApplicationRoleData": ApplicationRoleData,
    "AuditAnalysisResultResponse": AuditAnalysisResultResponse,
    "AuditResultResponse": AuditResultResponse,
    "AuthorizationResponse": AuthorizationResponse,
    "BusinessValuePortfolioRoleData": BusinessValuePortfolioRoleData,
    "CheckpointResultData": CheckpointResultData,
    "ComponentDetailResponse": ComponentDetailResponse,
    "ComponentSimpleRestData": ComponentSimpleRestData,
    "DataFlowElement": DataFlowElement,
    "DatapathData": DatapathData,
    "DefectDetailResponse": DefectDetailResponse,
    "DefectLineResponse": DefectLineResponse,
    "DefectNoteResponse": DefectNoteResponse,
    "DefectsDeltaDetailResponse": DefectsDeltaDetailResponse,
    "DefectsDeltaResponse": DefectsDeltaResponse,
    "DeliveryDefectsData": DeliveryDefectsData,
    "DeliveryFilesData": DeliveryFilesData,
    "FileData": FileData,
    "FileWithDefectsResponse": FileWithDefectsResponse,
    "FilterData": FilterData,
    "Finding": Finding,
    "FrameData": FrameData,
    "GlobalCounterResponse": GlobalCounterResponse,
    "GroupTagData": GroupTagData,
    "HrefData": HrefData,
    "InsightsComponentRestBean": InsightsComponentRestBean,
    "LicenseRestData": LicenseRestData,
    "ListComponentsRequest": ListComponentsRequest,
    "ListComponentsResponse": ListComponentsResponse,
    "ListInsightsComponentsResponse": ListInsightsComponentsResponse,
    "ListLicensesResponse": ListLicensesResponse,
    "ListObsolescencesResponse": ListObsolescencesResponse,
    "ListSecuritiesResponse": ListSecuritiesResponse,
    "Mapping": Mapping,
    "MetadataArchitectureData": MetadataArchitectureData,
    "MetadataInsightsData": MetadataInsightsData,
    "MetadataInsightsRiskData": MetadataInsightsRiskData,
    "MetricValueData": MetricValueData,
    "NavigationFilterData": NavigationFilterData,
    "ObsolescenceRestData": ObsolescenceRestData,
    "PaginationData": PaginationData,
    "PortfolioData": PortfolioData,
    "PortfolioDefinitionData": PortfolioDefinitionData,
    "PortfolioRoleData": PortfolioRoleData,
    "ProviderPortfolioRoleData": ProviderPortfolioRoleData,
    "RelationRestData": RelationRestData,
    "RuleDocumentationResponse": RuleDocumentationResponse,
    "Scan": Scan,
    "SearchImpactResponse": SearchImpactResponse,
    "SearchSourcesImpactRequest": SearchSourcesImpactRequest,
    "SearchTargetsImpactRequest": SearchTargetsImpactRequest,
    "SecurityRestData": SecurityRestData,
    "SourceChildSimpleRestData": SourceChildSimpleRestData,
    "SourceRootSimpleRestData": SourceRootSimpleRestData,
    "StaticDetails": StaticDetails,
    "SubGraphImpactRequest": SubGraphImpactRequest,
    "SubGraphImpactResponse": SubGraphImpactResponse,
    "UnparsedFileData": UnparsedFileData,
    "UserApplicationRoleResponse": UserApplicationRoleResponse,
    "UserAppsPermissionsResponse": UserAppsPermissionsResponse,
    "UserDetailResponse": UserDetailResponse,
    "UserGroupRequest": UserGroupRequest,
    "UserGroupResponse": UserGroupResponse,
    "UserInformationResponse": UserInformationResponse,
    "UserManagementRequest": UserManagementRequest,
    "UserPortfolioRoleData": UserPortfolioRoleData,
    "ValueCountData": ValueCountData,
    "ViolatedRuleResponse": ViolatedRuleResponse,
    "VulnerabilityData": VulnerabilityData,
    "VulnerabilityRestData": VulnerabilityRestData,
};
class HttpBasicAuth {
    applyToRequest(requestOptions) {
        requestOptions.auth = {
            username: this.username, password: this.password
        };
    }
}
exports.HttpBasicAuth = HttpBasicAuth;
class ApiKeyAuth {
    constructor(location, paramName) {
        this.location = location;
        this.paramName = paramName;
    }
    applyToRequest(requestOptions) {
        if (this.location == "query") {
            requestOptions.qs[this.paramName] = this.apiKey;
        }
        else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}
exports.ApiKeyAuth = ApiKeyAuth;
class OAuth {
    applyToRequest(requestOptions) {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}
exports.OAuth = OAuth;
class VoidAuth {
    applyToRequest(_) {
        // Do nothing
    }
}
exports.VoidAuth = VoidAuth;
var ActionPlanApiApiKeys;
(function (ActionPlanApiApiKeys) {
    ActionPlanApiApiKeys[ActionPlanApiApiKeys["Cookie"] = 0] = "Cookie";
})(ActionPlanApiApiKeys = exports.ActionPlanApiApiKeys || (exports.ActionPlanApiApiKeys = {}));
class ActionPlanApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'Cookie': new ApiKeyAuth('header', 'Cookie'),
            'basicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[ActionPlanApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.basicAuth.username = username;
    }
    set password(password) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Obtains the current and the past main metrics and indicators of an application for an action plan. If there are more than one action plans with the same name, this endpoint returns the most recent action plan's information.
     * @summary Get progress summary of an action plan
     * @param application Application name
     * @param name Action plan name
     * @param creation Action plan creation date
     */
    getActionPlan(application, name, creation) {
        const localVarPath = this.basePath + '/actionPlan';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'application' is not null or undefined
        if (application === null || application === undefined) {
            throw new Error('Required parameter application was null or undefined when calling getActionPlan.');
        }
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getActionPlan.');
        }
        if (application !== undefined) {
            localVarQueryParameters['application'] = ObjectSerializer.serialize(application, "string");
        }
        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "string");
        }
        if (creation !== undefined) {
            localVarQueryParameters['creation'] = ObjectSerializer.serialize(creation, "Date");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "ActionPlanProgressResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Obtains all defects included in an action plan. If there are more than one action plans with the same name, this endpoint returns the most recent action plan's information.
     * @summary Get all defects of an action plan
     * @param application Application name
     * @param name Action plan name
     * @param creation Action plan creation date
     */
    getActionPlanAllDefects(application, name, creation) {
        const localVarPath = this.basePath + '/actionPlan/defects/all';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'application' is not null or undefined
        if (application === null || application === undefined) {
            throw new Error('Required parameter application was null or undefined when calling getActionPlanAllDefects.');
        }
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getActionPlanAllDefects.');
        }
        if (application !== undefined) {
            localVarQueryParameters['application'] = ObjectSerializer.serialize(application, "string");
        }
        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "string");
        }
        if (creation !== undefined) {
            localVarQueryParameters['creation'] = ObjectSerializer.serialize(creation, "Date");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "ActionPlanDefectsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Obtains the pending defects of an action plan compared with a concrete analysis. If there are more than one action plans with the same name, this endpoint returns the most recent action plan's information. If there are more than one analysis with the same label, uses the most recent analysis of them.
     * @summary Get pending defects of an action plan
     * @param application Application name
     * @param name Action plan name
     * @param analysisLabel Analysis label. If empty it compares with last analysis
     * @param creation Action plan creation date
     * @param orderBy Sorting criteria: priority/effort
     * @param asc Sort ascending: true/false
     * @param limit Max number of defects returned
     * @param characteristics Comma-separated list of characteristics to filter by
     * @param languages Comma-separated list of languages to filter by
     * @param priorities Comma-separated list of priorities(Very low, Low, Normal, High, Very high) to filter by
     * @param fileContains Use this param to filter defects by file name
     */
    getActionPlanPendingDefects(application, name, analysisLabel, creation, orderBy, asc, limit, characteristics, languages, priorities, fileContains) {
        const localVarPath = this.basePath + '/actionPlan/defects/pending';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'application' is not null or undefined
        if (application === null || application === undefined) {
            throw new Error('Required parameter application was null or undefined when calling getActionPlanPendingDefects.');
        }
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getActionPlanPendingDefects.');
        }
        if (application !== undefined) {
            localVarQueryParameters['application'] = ObjectSerializer.serialize(application, "string");
        }
        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "string");
        }
        if (analysisLabel !== undefined) {
            localVarQueryParameters['analysisLabel'] = ObjectSerializer.serialize(analysisLabel, "string");
        }
        if (creation !== undefined) {
            localVarQueryParameters['creation'] = ObjectSerializer.serialize(creation, "Date");
        }
        if (orderBy !== undefined) {
            localVarQueryParameters['orderBy'] = ObjectSerializer.serialize(orderBy, "string");
        }
        if (asc !== undefined) {
            localVarQueryParameters['asc'] = ObjectSerializer.serialize(asc, "boolean");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (characteristics !== undefined) {
            localVarQueryParameters['characteristics'] = ObjectSerializer.serialize(characteristics, "string");
        }
        if (languages !== undefined) {
            localVarQueryParameters['languages'] = ObjectSerializer.serialize(languages, "string");
        }
        if (priorities !== undefined) {
            localVarQueryParameters['priorities'] = ObjectSerializer.serialize(priorities, "string");
        }
        if (fileContains !== undefined) {
            localVarQueryParameters['fileContains'] = ObjectSerializer.serialize(fileContains, "string");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "ActionPlanPendingDefectsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Obtains the removed defects of an action plan compared with a concrete analysis. If there are more than one action plans with the same name, this endpoint returns the most recent action plan's information. If there are more than one analysis with the same label, uses the most recent analysis of them.
     * @summary Get removed defects of an action plan
     * @param application Application name
     * @param name Action plan name
     * @param analysisLabel Analysis label. If empty it compares with last analysis
     * @param creation Action plan creation date
     */
    getActionPlanRemovedDefects(application, name, analysisLabel, creation) {
        const localVarPath = this.basePath + '/actionPlan/defects/removed';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'application' is not null or undefined
        if (application === null || application === undefined) {
            throw new Error('Required parameter application was null or undefined when calling getActionPlanRemovedDefects.');
        }
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getActionPlanRemovedDefects.');
        }
        if (application !== undefined) {
            localVarQueryParameters['application'] = ObjectSerializer.serialize(application, "string");
        }
        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "string");
        }
        if (analysisLabel !== undefined) {
            localVarQueryParameters['analysisLabel'] = ObjectSerializer.serialize(analysisLabel, "string");
        }
        if (creation !== undefined) {
            localVarQueryParameters['creation'] = ObjectSerializer.serialize(creation, "Date");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "ActionPlanRemovedDefectsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List action plans of an application.
     * @summary Get available action plans
     * @param application Application name
     */
    getActionPlans(application) {
        const localVarPath = this.basePath + '/actionPlans';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'application' is not null or undefined
        if (application === null || application === undefined) {
            throw new Error('Required parameter application was null or undefined when calling getActionPlans.');
        }
        if (application !== undefined) {
            localVarQueryParameters['application'] = ObjectSerializer.serialize(application, "string");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<ActionPlanDetailResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.ActionPlanApi = ActionPlanApi;
var ActionPlanReportsApiApiKeys;
(function (ActionPlanReportsApiApiKeys) {
    ActionPlanReportsApiApiKeys[ActionPlanReportsApiApiKeys["Cookie"] = 0] = "Cookie";
})(ActionPlanReportsApiApiKeys = exports.ActionPlanReportsApiApiKeys || (exports.ActionPlanReportsApiApiKeys = {}));
class ActionPlanReportsApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'Cookie': new ApiKeyAuth('header', 'Cookie'),
            'basicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[ActionPlanReportsApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.basicAuth.username = username;
    }
    set password(password) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Get progress report of an action plan or JSON with errors
     * @summary Get progress report of an action plan
     * @param application Application name
     * @param name Action plan name
     * @param creation Action plan creation date
     * @param type Type of report
     */
    generateReportActionPlanProgress(application, name, creation, type) {
        const localVarPath = this.basePath + '/actionPlan/progress/export';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'application' is not null or undefined
        if (application === null || application === undefined) {
            throw new Error('Required parameter application was null or undefined when calling generateReportActionPlanProgress.');
        }
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling generateReportActionPlanProgress.');
        }
        if (application !== undefined) {
            localVarQueryParameters['application'] = ObjectSerializer.serialize(application, "string");
        }
        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "string");
        }
        if (creation !== undefined) {
            localVarQueryParameters['creation'] = ObjectSerializer.serialize(creation, "Date");
        }
        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "string");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get security report of an action plan or JSON with errors
     * @summary Get security report of an action plan
     * @param application Application name
     * @param name Action plan name
     * @param creation Action plan creation date
     * @param type Type of report
     */
    generateReportActionPlanSecurity(application, name, creation, type) {
        const localVarPath = this.basePath + '/actionPlan/security/export';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'application' is not null or undefined
        if (application === null || application === undefined) {
            throw new Error('Required parameter application was null or undefined when calling generateReportActionPlanSecurity.');
        }
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling generateReportActionPlanSecurity.');
        }
        if (application !== undefined) {
            localVarQueryParameters['application'] = ObjectSerializer.serialize(application, "string");
        }
        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "string");
        }
        if (creation !== undefined) {
            localVarQueryParameters['creation'] = ObjectSerializer.serialize(creation, "Date");
        }
        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "string");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get security progress report of an action plan or JSON with errors
     * @summary Get security progress report of an action plan
     * @param application Application name
     * @param name Action plan name
     * @param creation Action plan creation date
     * @param type Type of report
     */
    generateReportActionPlanSecurityProgress(application, name, creation, type) {
        const localVarPath = this.basePath + '/actionPlan/security/progress/export';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'application' is not null or undefined
        if (application === null || application === undefined) {
            throw new Error('Required parameter application was null or undefined when calling generateReportActionPlanSecurityProgress.');
        }
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling generateReportActionPlanSecurityProgress.');
        }
        if (application !== undefined) {
            localVarQueryParameters['application'] = ObjectSerializer.serialize(application, "string");
        }
        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "string");
        }
        if (creation !== undefined) {
            localVarQueryParameters['creation'] = ObjectSerializer.serialize(creation, "Date");
        }
        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "string");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.ActionPlanReportsApi = ActionPlanReportsApi;
var AnalysesApiApiKeys;
(function (AnalysesApiApiKeys) {
    AnalysesApiApiKeys[AnalysesApiApiKeys["Cookie"] = 0] = "Cookie";
})(AnalysesApiApiKeys = exports.AnalysesApiApiKeys || (exports.AnalysesApiApiKeys = {}));
class AnalysesApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'Cookie': new ApiKeyAuth('header', 'Cookie'),
            'basicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[AnalysesApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.basicAuth.username = username;
    }
    set password(password) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Retrieves analysis results for a concrete analysis specified by code parameter.
     * @summary Get application analysis
     * @param code Analysis code
     */
    getAnalysis(code) {
        const localVarPath = this.basePath + '/apps/analysis/{code}'
            .replace('{' + 'code' + '}', encodeURIComponent(String(code)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling getAnalysis.');
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "AnalysisResultResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List analysis defects for a concrete analysis specified by analysisCode parameter.
     * @summary Get list of analysis defects
     * @param code Analysis code
     * @param characteristics Comma-separated list of characteristics to filter by
     * @param languages Comma-separated list of languages to filter by
     * @param priorities Comma-separated list of priorities(Very low, Low, Normal, High, Very high) to filter by
     * @param fileContains Use this param to filter defects by file name
     * @param orderBy Sorting criteria (one of &#39;priority&#39; or &#39;effort&#39;)
     * @param asc Set to true to sort ascending (default is not set), false for descending
     * @param page Number of results page (defaults to 1)
     * @param count How many defects in each page (defaults to 500)
     */
    getAnalysisDefects(code, characteristics, languages, priorities, fileContains, orderBy, asc, page, count) {
        const localVarPath = this.basePath + '/apps/analysis/{code}/defects'
            .replace('{' + 'code' + '}', encodeURIComponent(String(code)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling getAnalysisDefects.');
        }
        if (characteristics !== undefined) {
            localVarQueryParameters['characteristics'] = ObjectSerializer.serialize(characteristics, "string");
        }
        if (languages !== undefined) {
            localVarQueryParameters['languages'] = ObjectSerializer.serialize(languages, "string");
        }
        if (priorities !== undefined) {
            localVarQueryParameters['priorities'] = ObjectSerializer.serialize(priorities, "string");
        }
        if (fileContains !== undefined) {
            localVarQueryParameters['fileContains'] = ObjectSerializer.serialize(fileContains, "string");
        }
        if (orderBy !== undefined) {
            localVarQueryParameters['orderBy'] = ObjectSerializer.serialize(orderBy, "string");
        }
        if (asc !== undefined) {
            localVarQueryParameters['asc'] = ObjectSerializer.serialize(asc, "boolean");
        }
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (count !== undefined) {
            localVarQueryParameters['count'] = ObjectSerializer.serialize(count, "number");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "AnalysisDefectsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the list of new/removed defects in an analysis from the previous analysis.
     * @summary Get the list of new/removed defects in a comparison
     * @param code Analysis code
     * @param previouscode Previous analysis code
     * @param defectstype Either &#39;new&#39; or &#39;removed&#39;
     */
    getAnalysisDefectsDelta(code, previouscode, defectstype) {
        const localVarPath = this.basePath + '/apps/analysis/{code}/defects/compare/{previouscode}/{defectstype}'
            .replace('{' + 'code' + '}', encodeURIComponent(String(code)))
            .replace('{' + 'previouscode' + '}', encodeURIComponent(String(previouscode)))
            .replace('{' + 'defectstype' + '}', encodeURIComponent(String(defectstype)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling getAnalysisDefectsDelta.');
        }
        // verify required parameter 'previouscode' is not null or undefined
        if (previouscode === null || previouscode === undefined) {
            throw new Error('Required parameter previouscode was null or undefined when calling getAnalysisDefectsDelta.');
        }
        // verify required parameter 'defectstype' is not null or undefined
        if (defectstype === null || defectstype === undefined) {
            throw new Error('Required parameter defectstype was null or undefined when calling getAnalysisDefectsDelta.');
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "DefectsDeltaDetailResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the net number of new and removed defects and violated rules after comparing 2 given analyses.
     * @summary Get comparison of the defects found in two different analysis
     * @param code Analysis code
     * @param previouscode Previous analysis code
     */
    getAnalysisDelta(code, previouscode) {
        const localVarPath = this.basePath + '/apps/analysis/{code}/defects/compare/{previouscode}'
            .replace('{' + 'code' + '}', encodeURIComponent(String(code)))
            .replace('{' + 'previouscode' + '}', encodeURIComponent(String(previouscode)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling getAnalysisDelta.');
        }
        // verify required parameter 'previouscode' is not null or undefined
        if (previouscode === null || previouscode === undefined) {
            throw new Error('Required parameter previouscode was null or undefined when calling getAnalysisDelta.');
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "DefectsDeltaResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List files with metric values and defects for a specific analysis.
     * @summary Get list of files with metric values and defects for a specific analysis
     * @param code Analysis code
     */
    getAnalysisFiles(code) {
        const localVarPath = this.basePath + '/apps/analysis/{code}/files'
            .replace('{' + 'code' + '}', encodeURIComponent(String(code)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling getAnalysisFiles.');
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "AnalysisFilesResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List files with metric values and defects of the latest analysis for the named application.
     * @summary Get list of files with metric values and defects of the latest analysis
     * @param application Application name
     */
    getFiles(application) {
        const localVarPath = this.basePath + '/applications/files';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'application' is not null or undefined
        if (application === null || application === undefined) {
            throw new Error('Required parameter application was null or undefined when calling getFiles.');
        }
        if (application !== undefined) {
            localVarQueryParameters['application'] = ObjectSerializer.serialize(application, "string");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "AnalysisFilesResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves last analysis for the authenticated user and the application indicated.
     * @summary Get last analysis
     * @param application Application name
     */
    getLastAnalysis(application) {
        const localVarPath = this.basePath + '/applications/last_analysis';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'application' is not null or undefined
        if (application === null || application === undefined) {
            throw new Error('Required parameter application was null or undefined when calling getLastAnalysis.');
        }
        if (application !== undefined) {
            localVarQueryParameters['application'] = ObjectSerializer.serialize(application, "string");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "ApplicationAnalysisResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List all analysis codes for an application.
     * @summary Get list of all analysis codes for an application
     * @param application Application name
     * @param success Set to true or false to retrieve only succeeded or failed, respectively
     * @param filterPurgedAnalyses Set to true to not retrieve purged analyses
     * @param count Limit results
     */
    listAnalyses(application, success, filterPurgedAnalyses, count) {
        const localVarPath = this.basePath + '/applications/analyses';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'application' is not null or undefined
        if (application === null || application === undefined) {
            throw new Error('Required parameter application was null or undefined when calling listAnalyses.');
        }
        if (application !== undefined) {
            localVarQueryParameters['application'] = ObjectSerializer.serialize(application, "string");
        }
        if (success !== undefined) {
            localVarQueryParameters['success'] = ObjectSerializer.serialize(success, "boolean");
        }
        if (filterPurgedAnalyses !== undefined) {
            localVarQueryParameters['filterPurgedAnalyses'] = ObjectSerializer.serialize(filterPurgedAnalyses, "boolean");
        }
        if (count !== undefined) {
            localVarQueryParameters['count'] = ObjectSerializer.serialize(count, "number");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<AnalysisResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List analysis with different parameters to filter data. See parameters section.
     * @summary Get list of analysis
     * @param applicationName Application name to filter results
     * @param initDate Initial date to start search
     * @param endDate End date to search
     * @param status Status to filter analysis
     * @param auditStatus Audit status to filter analysis (only apply to analysis that has audits)
     * @param deliveries If the list of analysis must include only deliveries (true) or ignore deliveries (false), if this parameter has not value then all analysis will be returned
     * @param page Number of results page (defaults to 1)
     * @param count How many analysis in each page (defaults to 500)
     */
    listAnalysis(applicationName, initDate, endDate, status, auditStatus, deliveries, page, count) {
        const localVarPath = this.basePath + '/analysis/list';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (applicationName !== undefined) {
            localVarQueryParameters['applicationName'] = ObjectSerializer.serialize(applicationName, "string");
        }
        if (initDate !== undefined) {
            localVarQueryParameters['initDate'] = ObjectSerializer.serialize(initDate, "string");
        }
        if (endDate !== undefined) {
            localVarQueryParameters['endDate'] = ObjectSerializer.serialize(endDate, "string");
        }
        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "string");
        }
        if (auditStatus !== undefined) {
            localVarQueryParameters['auditStatus'] = ObjectSerializer.serialize(auditStatus, "string");
        }
        if (deliveries !== undefined) {
            localVarQueryParameters['deliveries'] = ObjectSerializer.serialize(deliveries, "boolean");
        }
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (count !== undefined) {
            localVarQueryParameters['count'] = ObjectSerializer.serialize(count, "number");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<AnalysisResultResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.AnalysesApi = AnalysesApi;
var AnalysesReportsApiApiKeys;
(function (AnalysesReportsApiApiKeys) {
    AnalysesReportsApiApiKeys[AnalysesReportsApiApiKeys["Cookie"] = 0] = "Cookie";
})(AnalysesReportsApiApiKeys = exports.AnalysesReportsApiApiKeys || (exports.AnalysesReportsApiApiKeys = {}));
class AnalysesReportsApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'Cookie': new ApiKeyAuth('header', 'Cookie'),
            'basicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[AnalysesReportsApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.basicAuth.username = username;
    }
    set password(password) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Obtains a CSV report of the specified analysis code or the last analysis of the application name.
     * @summary Get defects CSV report of an analysis
     * @param code Analysis code
     * @param application Application name
     */
    generateReportDefects(code, application) {
        const localVarPath = this.basePath + '/applications/analysis/defects/export';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (code !== undefined) {
            localVarQueryParameters['code'] = ObjectSerializer.serialize(code, "string");
        }
        if (application !== undefined) {
            localVarQueryParameters['application'] = ObjectSerializer.serialize(application, "string");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Obtains a report of the specified analysis code or the last analysis of the application name in PDF format.
     * @summary Get PDF report of an analysis
     * @param code Analysis code
     * @param application Application name
     */
    generateReportSummaryCA(code, application) {
        const localVarPath = this.basePath + '/applications/analysis/summary/export';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (code !== undefined) {
            localVarQueryParameters['code'] = ObjectSerializer.serialize(code, "string");
        }
        if (application !== undefined) {
            localVarQueryParameters['application'] = ObjectSerializer.serialize(application, "string");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Obtains a security report of the specified analysis code or the last analysis of the application name in PDF format.
     * @summary Get security PDF report of an analysis
     * @param code Analysis code
     * @param application Application name
     */
    generateReportSummaryCS(code, application) {
        const localVarPath = this.basePath + '/applications/analysis/security/summary/export';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (code !== undefined) {
            localVarQueryParameters['code'] = ObjectSerializer.serialize(code, "string");
        }
        if (application !== undefined) {
            localVarQueryParameters['application'] = ObjectSerializer.serialize(application, "string");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Obtains a security report of the specified analysis code or the last analysis of the application name in CSV or Threadfix format.
     * @summary Get security CSV/Threadfix report of an analysis
     * @param code Analysis code
     * @param application Application name
     * @param type type of report
     */
    generateReportVulnerabilities(code, application, type) {
        const localVarPath = this.basePath + '/applications/analysis/vulnerabilities/export';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (code !== undefined) {
            localVarQueryParameters['code'] = ObjectSerializer.serialize(code, "string");
        }
        if (application !== undefined) {
            localVarQueryParameters['application'] = ObjectSerializer.serialize(application, "string");
        }
        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "string");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.AnalysesReportsApi = AnalysesReportsApi;
var ApplicationApiApiKeys;
(function (ApplicationApiApiKeys) {
    ApplicationApiApiKeys[ApplicationApiApiKeys["Cookie"] = 0] = "Cookie";
})(ApplicationApiApiKeys = exports.ApplicationApiApiKeys || (exports.ApplicationApiApiKeys = {}));
class ApplicationApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'Cookie': new ApiKeyAuth('header', 'Cookie'),
            'basicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[ApplicationApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.basicAuth.username = username;
    }
    set password(password) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Get suppression rules for application given as parameter.
     * @summary Get suppression rules
     * @param application Application name
     */
    downloadSuppressions(application) {
        const localVarPath = this.basePath + '/qualitymodel/suppressions';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'application' is not null or undefined
        if (application === null || application === undefined) {
            throw new Error('Required parameter application was null or undefined when calling downloadSuppressions.');
        }
        if (application !== undefined) {
            localVarQueryParameters['application'] = ObjectSerializer.serialize(application, "string");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves applications for the authenticated user.
     * @summary Get applications
     */
    getApplications() {
        const localVarPath = this.basePath + '/applications';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<ApplicationResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves applications for the authenticated user filtered.
     * @summary Get applications filtered
     * @param applicationName Application name to filter
     * @param exactApplicationName Indicates if the applicationName must be equals (ignore case). Only apply if applicationName is provided
     * @param initDateAnalysis Initial date to start search applications that are analyzed after this date
     * @param endDateAnalysis End date to start search applications that are analyzed before this date
     * @param page Number of results page (defaults to 1)
     * @param count How many applications in each page (defaults to 500)
     * @param orderBy &#39;Order by&#39; for results
     * @param asc Ascending or descending order
     */
    getApplicationsList(applicationName, exactApplicationName, initDateAnalysis, endDateAnalysis, page, count, orderBy, asc) {
        const localVarPath = this.basePath + '/applications/list';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (applicationName !== undefined) {
            localVarQueryParameters['applicationName'] = ObjectSerializer.serialize(applicationName, "string");
        }
        if (exactApplicationName !== undefined) {
            localVarQueryParameters['exactApplicationName'] = ObjectSerializer.serialize(exactApplicationName, "boolean");
        }
        if (initDateAnalysis !== undefined) {
            localVarQueryParameters['initDateAnalysis'] = ObjectSerializer.serialize(initDateAnalysis, "string");
        }
        if (endDateAnalysis !== undefined) {
            localVarQueryParameters['endDateAnalysis'] = ObjectSerializer.serialize(endDateAnalysis, "string");
        }
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (count !== undefined) {
            localVarQueryParameters['count'] = ObjectSerializer.serialize(count, "number");
        }
        if (orderBy !== undefined) {
            localVarQueryParameters['orderBy'] = ObjectSerializer.serialize(orderBy, "string");
        }
        if (asc !== undefined) {
            localVarQueryParameters['asc'] = ObjectSerializer.serialize(asc, "boolean");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<ApplicationResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List application defects for the indicated application.
     * @summary Get list of application defects
     * @param application Application name
     * @param characteristics Comma-separated list of characteristics to filter by
     * @param languages Comma-separated list of languages to filter by
     * @param priorities Comma-separated list of priorities(Very low, Low, Normal, High, Very high) to filter by
     * @param fileContains Use this param to filter defects by file name
     * @param orderBy Sorting criteria (one of &#39;priority&#39; or &#39;effort&#39;)
     * @param asc Set to true to sort ascending (default is not set), false for descending
     * @param page Number of results page (defaults to 1)
     * @param count How many defects in each page (defaults to 500)
     */
    getDefects(application, characteristics, languages, priorities, fileContains, orderBy, asc, page, count) {
        const localVarPath = this.basePath + '/applications/defects';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'application' is not null or undefined
        if (application === null || application === undefined) {
            throw new Error('Required parameter application was null or undefined when calling getDefects.');
        }
        if (application !== undefined) {
            localVarQueryParameters['application'] = ObjectSerializer.serialize(application, "string");
        }
        if (characteristics !== undefined) {
            localVarQueryParameters['characteristics'] = ObjectSerializer.serialize(characteristics, "string");
        }
        if (languages !== undefined) {
            localVarQueryParameters['languages'] = ObjectSerializer.serialize(languages, "string");
        }
        if (priorities !== undefined) {
            localVarQueryParameters['priorities'] = ObjectSerializer.serialize(priorities, "string");
        }
        if (fileContains !== undefined) {
            localVarQueryParameters['fileContains'] = ObjectSerializer.serialize(fileContains, "string");
        }
        if (orderBy !== undefined) {
            localVarQueryParameters['orderBy'] = ObjectSerializer.serialize(orderBy, "string");
        }
        if (asc !== undefined) {
            localVarQueryParameters['asc'] = ObjectSerializer.serialize(asc, "boolean");
        }
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (count !== undefined) {
            localVarQueryParameters['count'] = ObjectSerializer.serialize(count, "number");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "AnalysisDefectsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Obtains the global metrics of indicated analysis.
     * @summary Get analysis global metrics
     * @param code Analysis code
     */
    getMetricsMap(code) {
        const localVarPath = this.basePath + '/metrics';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling getMetricsMap.');
        }
        if (code !== undefined) {
            localVarQueryParameters['code'] = ObjectSerializer.serialize(code, "string");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "{ [key: string]: any; }");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List application vulnerabilities in Threadfix format for the given application or analysis code.
     * @summary Get list of application vulnerabilities in Threadfix format
     * @param application Application name
     * @param code Analysis code
     */
    getThreadfixFindings(application, code) {
        const localVarPath = this.basePath + '/applications/defects/export/threadfix';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (application !== undefined) {
            localVarQueryParameters['application'] = ObjectSerializer.serialize(application, "string");
        }
        if (code !== undefined) {
            localVarQueryParameters['code'] = ObjectSerializer.serialize(code, "string");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Scan");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.ApplicationApi = ApplicationApi;
var ArchitectureApiApiKeys;
(function (ArchitectureApiApiKeys) {
    ArchitectureApiApiKeys[ArchitectureApiApiKeys["Cookie"] = 0] = "Cookie";
})(ArchitectureApiApiKeys = exports.ArchitectureApiApiKeys || (exports.ArchitectureApiApiKeys = {}));
class ArchitectureApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'Cookie': new ApiKeyAuth('header', 'Cookie'),
            'basicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[ArchitectureApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.basicAuth.username = username;
    }
    set password(password) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * List components in analysis for a concrete analysis specified by analysisCode parameter or application name specified in applicationName parameter by filter and pagination.
     * @summary Get list of components by filter and pagination
     * @param body List components request
     */
    listComponents(body) {
        const localVarPath = this.basePath + '/arch/list';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling listComponents.');
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ListComponentsRequest")
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "ListComponentsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List of sources that impact on a component with the specified targetId in analysis for a concrete analysis specified by analysisCode parameter or application name specified in applicationName parameter by filters and pagination.
     * @summary Get list of sources that impact on a component with the specified targetId
     * @param body Analysis impact request for sources
     */
    searchSources(body) {
        const localVarPath = this.basePath + '/arch/impact/searchSources';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling searchSources.');
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "SearchSourcesImpactRequest")
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "SearchImpactResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List impacted components in analysis for a concrete analysis specified by analysisCode parameter or application name specified in applicationName parameter by filters and pagination.
     * @summary Get list of impacted components
     * @param body Analysis impact request
     */
    searchTargets(body) {
        const localVarPath = this.basePath + '/arch/impact/searchTargets';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling searchTargets.');
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "SearchTargetsImpactRequest")
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "SearchImpactResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get sub graph of analysis impact in analysis for a concrete analysis specified by analysisCode parameter or application name specified in applicationName parameter by source id and target id.
     * @summary Get sub graph of analysis impact
     * @param body Get sub graph of analysis impact
     */
    subGraph(body) {
        const localVarPath = this.basePath + '/arch/impact/subGraph';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling subGraph.');
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "SubGraphImpactRequest")
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "SubGraphImpactResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.ArchitectureApi = ArchitectureApi;
var AuditApiApiKeys;
(function (AuditApiApiKeys) {
    AuditApiApiKeys[AuditApiApiKeys["Cookie"] = 0] = "Cookie";
})(AuditApiApiKeys = exports.AuditApiApiKeys || (exports.AuditApiApiKeys = {}));
class AuditApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'Cookie': new ApiKeyAuth('header', 'Cookie'),
            'basicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[AuditApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.basicAuth.username = username;
    }
    set password(password) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Obtains an audit report of the specified delivery in PDF format. It is necessary an analysis code or an application name and change request
     * @summary Get audit result PDF report
     * @param code Analysis code
     * @param application Application name
     * @param changeRequest Change request
     * @param deliveryLabel Delivery label
     */
    generateAuditResultReport(code, application, changeRequest, deliveryLabel) {
        const localVarPath = this.basePath + '/audits/result/export';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (code !== undefined) {
            localVarQueryParameters['code'] = ObjectSerializer.serialize(code, "string");
        }
        if (application !== undefined) {
            localVarQueryParameters['application'] = ObjectSerializer.serialize(application, "string");
        }
        if (changeRequest !== undefined) {
            localVarQueryParameters['changeRequest'] = ObjectSerializer.serialize(changeRequest, "string");
        }
        if (deliveryLabel !== undefined) {
            localVarQueryParameters['deliveryLabel'] = ObjectSerializer.serialize(deliveryLabel, "string");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get defects of an audit result
     * @summary Get audit result defects
     * @param deliveryCode Delivery code
     * @param characteristics Comma-separated list of characteristics to filter by
     * @param languages Comma-separated list of languages to filter by
     * @param priorities Comma-separated list of priorities(Very low, Low, Normal, High, Very high) to filter by
     * @param fileContains Use this param to filter defects by file name
     * @param orderBy Sorting criteria: priority/effort
     * @param asc Sort ascending: true/false
     * @param limit Max number of defects returned
     */
    getAuditDefects(deliveryCode, characteristics, languages, priorities, fileContains, orderBy, asc, limit) {
        const localVarPath = this.basePath + '/auditResult/defects';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'deliveryCode' is not null or undefined
        if (deliveryCode === null || deliveryCode === undefined) {
            throw new Error('Required parameter deliveryCode was null or undefined when calling getAuditDefects.');
        }
        if (deliveryCode !== undefined) {
            localVarQueryParameters['deliveryCode'] = ObjectSerializer.serialize(deliveryCode, "string");
        }
        if (characteristics !== undefined) {
            localVarQueryParameters['characteristics'] = ObjectSerializer.serialize(characteristics, "string");
        }
        if (languages !== undefined) {
            localVarQueryParameters['languages'] = ObjectSerializer.serialize(languages, "string");
        }
        if (priorities !== undefined) {
            localVarQueryParameters['priorities'] = ObjectSerializer.serialize(priorities, "string");
        }
        if (fileContains !== undefined) {
            localVarQueryParameters['fileContains'] = ObjectSerializer.serialize(fileContains, "string");
        }
        if (orderBy !== undefined) {
            localVarQueryParameters['orderBy'] = ObjectSerializer.serialize(orderBy, "string");
        }
        if (asc !== undefined) {
            localVarQueryParameters['asc'] = ObjectSerializer.serialize(asc, "boolean");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<DefectDetailResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get an audit result with defects count by priority
     * @summary Get audit result
     * @param deliveryCode Delivery code
     */
    getAuditResult(deliveryCode) {
        const localVarPath = this.basePath + '/auditResult';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'deliveryCode' is not null or undefined
        if (deliveryCode === null || deliveryCode === undefined) {
            throw new Error('Required parameter deliveryCode was null or undefined when calling getAuditResult.');
        }
        if (deliveryCode !== undefined) {
            localVarQueryParameters['deliveryCode'] = ObjectSerializer.serialize(deliveryCode, "string");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "AuditResultResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List files with a violated rule of an audit
     * @summary Get list of files
     * @param application Application name
     * @param deliveryCode Delivery code
     * @param ruleCode Rule code
     * @param checkpoint Checkpoint id
     */
    getFilesWithGET(application, deliveryCode, ruleCode, checkpoint) {
        const localVarPath = this.basePath + '/audits/checkpoints/violatedrules/files';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'application' is not null or undefined
        if (application === null || application === undefined) {
            throw new Error('Required parameter application was null or undefined when calling getFilesWithGET.');
        }
        // verify required parameter 'deliveryCode' is not null or undefined
        if (deliveryCode === null || deliveryCode === undefined) {
            throw new Error('Required parameter deliveryCode was null or undefined when calling getFilesWithGET.');
        }
        // verify required parameter 'ruleCode' is not null or undefined
        if (ruleCode === null || ruleCode === undefined) {
            throw new Error('Required parameter ruleCode was null or undefined when calling getFilesWithGET.');
        }
        // verify required parameter 'checkpoint' is not null or undefined
        if (checkpoint === null || checkpoint === undefined) {
            throw new Error('Required parameter checkpoint was null or undefined when calling getFilesWithGET.');
        }
        if (application !== undefined) {
            localVarQueryParameters['application'] = ObjectSerializer.serialize(application, "string");
        }
        if (deliveryCode !== undefined) {
            localVarQueryParameters['deliveryCode'] = ObjectSerializer.serialize(deliveryCode, "string");
        }
        if (ruleCode !== undefined) {
            localVarQueryParameters['ruleCode'] = ObjectSerializer.serialize(ruleCode, "string");
        }
        if (checkpoint !== undefined) {
            localVarQueryParameters['checkpoint'] = ObjectSerializer.serialize(checkpoint, "string");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<FileWithDefectsResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List defects in a file
     * @summary Get list of defects of file
     * @param application Application name
     * @param deliveryCode Delivery code
     * @param ruleCode Rule code
     * @param file File name
     * @param checkpoint Checkpoint id
     */
    getLinesWithGET(application, deliveryCode, ruleCode, file, checkpoint) {
        const localVarPath = this.basePath + '/audits/checkpoints/violatedrules/files/defects';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'application' is not null or undefined
        if (application === null || application === undefined) {
            throw new Error('Required parameter application was null or undefined when calling getLinesWithGET.');
        }
        // verify required parameter 'deliveryCode' is not null or undefined
        if (deliveryCode === null || deliveryCode === undefined) {
            throw new Error('Required parameter deliveryCode was null or undefined when calling getLinesWithGET.');
        }
        // verify required parameter 'ruleCode' is not null or undefined
        if (ruleCode === null || ruleCode === undefined) {
            throw new Error('Required parameter ruleCode was null or undefined when calling getLinesWithGET.');
        }
        // verify required parameter 'file' is not null or undefined
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling getLinesWithGET.');
        }
        // verify required parameter 'checkpoint' is not null or undefined
        if (checkpoint === null || checkpoint === undefined) {
            throw new Error('Required parameter checkpoint was null or undefined when calling getLinesWithGET.');
        }
        if (application !== undefined) {
            localVarQueryParameters['application'] = ObjectSerializer.serialize(application, "string");
        }
        if (deliveryCode !== undefined) {
            localVarQueryParameters['deliveryCode'] = ObjectSerializer.serialize(deliveryCode, "string");
        }
        if (ruleCode !== undefined) {
            localVarQueryParameters['ruleCode'] = ObjectSerializer.serialize(ruleCode, "string");
        }
        if (file !== undefined) {
            localVarQueryParameters['file'] = ObjectSerializer.serialize(file, "string");
        }
        if (checkpoint !== undefined) {
            localVarQueryParameters['checkpoint'] = ObjectSerializer.serialize(checkpoint, "string");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<DefectLineResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.AuditApi = AuditApi;
var DefectApiApiKeys;
(function (DefectApiApiKeys) {
    DefectApiApiKeys[DefectApiApiKeys["Cookie"] = 0] = "Cookie";
})(DefectApiApiKeys = exports.DefectApiApiKeys || (exports.DefectApiApiKeys = {}));
class DefectApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'Cookie': new ApiKeyAuth('header', 'Cookie'),
            'basicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[DefectApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.basicAuth.username = username;
    }
    set password(password) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Obtains the list of notes associated to this defect.
     * @summary Get defect notes
     * @param defectId Defect identifier
     */
    getDefectNotes(defectId) {
        const localVarPath = this.basePath + '/defect/{defectId}/notes'
            .replace('{' + 'defectId' + '}', encodeURIComponent(String(defectId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'defectId' is not null or undefined
        if (defectId === null || defectId === undefined) {
            throw new Error('Required parameter defectId was null or undefined when calling getDefectNotes.');
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<DefectNoteResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Obtains the list of defects in a file for a concrete violated rule.
     * @summary Get defects of file
     * @param application Application name
     * @param analysisCode Analysis code
     * @param ruleCode Rule code
     * @param file File name including path
     */
    getViolatedRuleFileDefectsViaGET(application, analysisCode, ruleCode, file) {
        const localVarPath = this.basePath + '/violatedrules/files/defects';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'application' is not null or undefined
        if (application === null || application === undefined) {
            throw new Error('Required parameter application was null or undefined when calling getViolatedRuleFileDefectsViaGET.');
        }
        // verify required parameter 'analysisCode' is not null or undefined
        if (analysisCode === null || analysisCode === undefined) {
            throw new Error('Required parameter analysisCode was null or undefined when calling getViolatedRuleFileDefectsViaGET.');
        }
        // verify required parameter 'ruleCode' is not null or undefined
        if (ruleCode === null || ruleCode === undefined) {
            throw new Error('Required parameter ruleCode was null or undefined when calling getViolatedRuleFileDefectsViaGET.');
        }
        // verify required parameter 'file' is not null or undefined
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling getViolatedRuleFileDefectsViaGET.');
        }
        if (application !== undefined) {
            localVarQueryParameters['application'] = ObjectSerializer.serialize(application, "string");
        }
        if (analysisCode !== undefined) {
            localVarQueryParameters['analysisCode'] = ObjectSerializer.serialize(analysisCode, "string");
        }
        if (ruleCode !== undefined) {
            localVarQueryParameters['ruleCode'] = ObjectSerializer.serialize(ruleCode, "string");
        }
        if (file !== undefined) {
            localVarQueryParameters['file'] = ObjectSerializer.serialize(file, "string");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<DefectLineResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Obtains the list of files where the violated rule affects.
     * @summary Get files of a violated rule
     * @param application Application name
     * @param analysisCode Analysis code
     * @param ruleCode Rule code
     */
    getViolatedRuleFilesViaGET(application, analysisCode, ruleCode) {
        const localVarPath = this.basePath + '/violatedrules/files';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'application' is not null or undefined
        if (application === null || application === undefined) {
            throw new Error('Required parameter application was null or undefined when calling getViolatedRuleFilesViaGET.');
        }
        // verify required parameter 'analysisCode' is not null or undefined
        if (analysisCode === null || analysisCode === undefined) {
            throw new Error('Required parameter analysisCode was null or undefined when calling getViolatedRuleFilesViaGET.');
        }
        // verify required parameter 'ruleCode' is not null or undefined
        if (ruleCode === null || ruleCode === undefined) {
            throw new Error('Required parameter ruleCode was null or undefined when calling getViolatedRuleFilesViaGET.');
        }
        if (application !== undefined) {
            localVarQueryParameters['application'] = ObjectSerializer.serialize(application, "string");
        }
        if (analysisCode !== undefined) {
            localVarQueryParameters['analysisCode'] = ObjectSerializer.serialize(analysisCode, "string");
        }
        if (ruleCode !== undefined) {
            localVarQueryParameters['ruleCode'] = ObjectSerializer.serialize(ruleCode, "string");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<FileWithDefectsResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Obtains the list of violated rules of an analysis for the authenticated user.
     * @summary Get violated rules of an analysis
     * @param application Application name
     * @param analysisCode Analysis code
     * @param characteristic CQM characteristic
     * @param language CQM technology
     * @param priority Rule priority
     * @param vulnerabilityType Vulnerability type
     * @param tag Rule tag
     * @param onlyCodeSecurity Only Code Security rules
     */
    getViolatedRules(application, analysisCode, characteristic, language, priority, vulnerabilityType, tag, onlyCodeSecurity) {
        const localVarPath = this.basePath + '/violatedrules';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'application' is not null or undefined
        if (application === null || application === undefined) {
            throw new Error('Required parameter application was null or undefined when calling getViolatedRules.');
        }
        if (application !== undefined) {
            localVarQueryParameters['application'] = ObjectSerializer.serialize(application, "string");
        }
        if (analysisCode !== undefined) {
            localVarQueryParameters['analysisCode'] = ObjectSerializer.serialize(analysisCode, "string");
        }
        if (characteristic !== undefined) {
            localVarQueryParameters['characteristic'] = ObjectSerializer.serialize(characteristic, "string");
        }
        if (language !== undefined) {
            localVarQueryParameters['language'] = ObjectSerializer.serialize(language, "string");
        }
        if (priority !== undefined) {
            localVarQueryParameters['priority'] = ObjectSerializer.serialize(priority, "string");
        }
        if (vulnerabilityType !== undefined) {
            localVarQueryParameters['vulnerabilityType'] = ObjectSerializer.serialize(vulnerabilityType, "string");
        }
        if (tag !== undefined) {
            localVarQueryParameters['tag'] = ObjectSerializer.serialize(tag, "string");
        }
        if (onlyCodeSecurity !== undefined) {
            localVarQueryParameters['onlyCodeSecurity'] = ObjectSerializer.serialize(onlyCodeSecurity, "boolean");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<ViolatedRuleResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a suppression rule for this defect.
     * @summary Create suppresion rule for a defect
     * @param defectId Defect identifier
     * @param why Mute reason
     * @param comment Mute comment
     */
    muteDefect(defectId, why, comment) {
        const localVarPath = this.basePath + '/defect/{defectId}/mute'
            .replace('{' + 'defectId' + '}', encodeURIComponent(String(defectId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'defectId' is not null or undefined
        if (defectId === null || defectId === undefined) {
            throw new Error('Required parameter defectId was null or undefined when calling muteDefect.');
        }
        if (why !== undefined) {
            localVarQueryParameters['why'] = ObjectSerializer.serialize(why, "string");
        }
        if (comment !== undefined) {
            localVarQueryParameters['comment'] = ObjectSerializer.serialize(comment, "string");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update status of this defect and add a note, possible status are (NONE, TO_REVIEW, REVIEWED)
     * @summary Update the status of a defect
     * @param defectId Defect identifier
     * @param status Defect status
     * @param note Note detail
     */
    updateStatus(defectId, status, note) {
        const localVarPath = this.basePath + '/defect/{defectId}/status'
            .replace('{' + 'defectId' + '}', encodeURIComponent(String(defectId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'defectId' is not null or undefined
        if (defectId === null || defectId === undefined) {
            throw new Error('Required parameter defectId was null or undefined when calling updateStatus.');
        }
        // verify required parameter 'status' is not null or undefined
        if (status === null || status === undefined) {
            throw new Error('Required parameter status was null or undefined when calling updateStatus.');
        }
        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "string");
        }
        if (note !== undefined) {
            localVarQueryParameters['note'] = ObjectSerializer.serialize(note, "string");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.DefectApi = DefectApi;
var DeliveryApiApiKeys;
(function (DeliveryApiApiKeys) {
    DeliveryApiApiKeys[DeliveryApiApiKeys["Cookie"] = 0] = "Cookie";
})(DeliveryApiApiKeys = exports.DeliveryApiApiKeys || (exports.DeliveryApiApiKeys = {}));
class DeliveryApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'Cookie': new ApiKeyAuth('header', 'Cookie'),
            'basicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[DeliveryApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.basicAuth.username = username;
    }
    set password(password) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Obtains the information of delivery indicating the code of the delivery.
     * @summary Get information of a delivery by code
     * @param code Delivery code
     */
    getDelivery(code) {
        const localVarPath = this.basePath + '/deliveries/{code}'
            .replace('{' + 'code' + '}', encodeURIComponent(String(code)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling getDelivery.');
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "AnalysisResultResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Obtains the deliveries indicating the name of the application.
     * @summary Get deliveries of an application
     * @param application Application name
     * @param maxdays Max number of days old of deliveries returned
     * @param page Number of results page (defaults to 1)
     * @param count Limit results
     * @param auditSuccess Set to true or false to retrieve only succeeded or failed audit delivery, respectively
     * @param filterPurgedAnalyses Set to true to not retrieve purged analyses
     * @param changeRequestFilter To filter deliveries by changeRequest
     */
    listDeliveries(application, maxdays, page, count, auditSuccess, filterPurgedAnalyses, changeRequestFilter) {
        const localVarPath = this.basePath + '/applications/deliveries';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'application' is not null or undefined
        if (application === null || application === undefined) {
            throw new Error('Required parameter application was null or undefined when calling listDeliveries.');
        }
        if (maxdays !== undefined) {
            localVarQueryParameters['maxdays'] = ObjectSerializer.serialize(maxdays, "number");
        }
        if (application !== undefined) {
            localVarQueryParameters['application'] = ObjectSerializer.serialize(application, "string");
        }
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (count !== undefined) {
            localVarQueryParameters['count'] = ObjectSerializer.serialize(count, "number");
        }
        if (auditSuccess !== undefined) {
            localVarQueryParameters['auditSuccess'] = ObjectSerializer.serialize(auditSuccess, "boolean");
        }
        if (filterPurgedAnalyses !== undefined) {
            localVarQueryParameters['filterPurgedAnalyses'] = ObjectSerializer.serialize(filterPurgedAnalyses, "boolean");
        }
        if (changeRequestFilter !== undefined) {
            localVarQueryParameters['changeRequestFilter'] = ObjectSerializer.serialize(changeRequestFilter, "string");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<AnalysisResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.DeliveryApi = DeliveryApi;
var DocumentationApiApiKeys;
(function (DocumentationApiApiKeys) {
    DocumentationApiApiKeys[DocumentationApiApiKeys["Cookie"] = 0] = "Cookie";
})(DocumentationApiApiKeys = exports.DocumentationApiApiKeys || (exports.DocumentationApiApiKeys = {}));
class DocumentationApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'Cookie': new ApiKeyAuth('header', 'Cookie'),
            'basicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[DocumentationApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.basicAuth.username = username;
    }
    set password(password) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Obtains the documentation of a rule.
     * @summary Get rule's documentation
     * @param modelId Model id
     * @param code Rule code
     * @param application Application name
     */
    getRuleDoc(modelId, code, application) {
        const localVarPath = this.basePath + '/doc/rule';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'modelId' is not null or undefined
        if (modelId === null || modelId === undefined) {
            throw new Error('Required parameter modelId was null or undefined when calling getRuleDoc.');
        }
        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling getRuleDoc.');
        }
        // verify required parameter 'application' is not null or undefined
        if (application === null || application === undefined) {
            throw new Error('Required parameter application was null or undefined when calling getRuleDoc.');
        }
        if (modelId !== undefined) {
            localVarQueryParameters['modelId'] = ObjectSerializer.serialize(modelId, "string");
        }
        if (code !== undefined) {
            localVarQueryParameters['code'] = ObjectSerializer.serialize(code, "string");
        }
        if (application !== undefined) {
            localVarQueryParameters['application'] = ObjectSerializer.serialize(application, "string");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "RuleDocumentationResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.DocumentationApi = DocumentationApi;
var GlobalStatsApiApiKeys;
(function (GlobalStatsApiApiKeys) {
    GlobalStatsApiApiKeys[GlobalStatsApiApiKeys["Cookie"] = 0] = "Cookie";
})(GlobalStatsApiApiKeys = exports.GlobalStatsApiApiKeys || (exports.GlobalStatsApiApiKeys = {}));
class GlobalStatsApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'Cookie': new ApiKeyAuth('header', 'Cookie'),
            'basicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[GlobalStatsApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.basicAuth.username = username;
    }
    set password(password) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Obtains the user's global information about locs, files and analysis as JSON.
     * @summary Get the user information
     */
    getStats() {
        const localVarPath = this.basePath + '/stats';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<GlobalCounterResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.GlobalStatsApi = GlobalStatsApi;
var InformationApiApiKeys;
(function (InformationApiApiKeys) {
    InformationApiApiKeys[InformationApiApiKeys["Cookie"] = 0] = "Cookie";
})(InformationApiApiKeys = exports.InformationApiApiKeys || (exports.InformationApiApiKeys = {}));
class InformationApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'Cookie': new ApiKeyAuth('header', 'Cookie'),
            'basicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[InformationApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.basicAuth.username = username;
    }
    set password(password) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Obtains the user's information
     * @summary Get user info
     */
    getInformation() {
        const localVarPath = this.basePath + '/info';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "UserInformationResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.InformationApi = InformationApi;
var InsightsApiApiKeys;
(function (InsightsApiApiKeys) {
    InsightsApiApiKeys[InsightsApiApiKeys["Cookie"] = 0] = "Cookie";
})(InsightsApiApiKeys = exports.InsightsApiApiKeys || (exports.InsightsApiApiKeys = {}));
class InsightsApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'Cookie': new ApiKeyAuth('header', 'Cookie'),
            'basicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[InsightsApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.basicAuth.username = username;
    }
    set password(password) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * List components in analysis for an application name specified in application parameter and a concrete analysis specified by analysisCode parameter.
     * @summary Get list of components
     * @param application Application name
     * @param analysisCode Analysis code
     */
    listInsightsComponents(application, analysisCode) {
        const localVarPath = this.basePath + '/insights/analysis/components';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'application' is not null or undefined
        if (application === null || application === undefined) {
            throw new Error('Required parameter application was null or undefined when calling listInsightsComponents.');
        }
        // verify required parameter 'analysisCode' is not null or undefined
        if (analysisCode === null || analysisCode === undefined) {
            throw new Error('Required parameter analysisCode was null or undefined when calling listInsightsComponents.');
        }
        if (application !== undefined) {
            localVarQueryParameters['application'] = ObjectSerializer.serialize(application, "string");
        }
        if (analysisCode !== undefined) {
            localVarQueryParameters['analysisCode'] = ObjectSerializer.serialize(analysisCode, "string");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "ListInsightsComponentsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List licenses in analysis for an application name specified in application parameter and a concrete analysis specified by analysisCode parameter.
     * @summary Get list of licenses
     * @param application Application name
     * @param analysisCode Analysis code
     */
    listLicenses(application, analysisCode) {
        const localVarPath = this.basePath + '/insights/analysis/licenses';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'application' is not null or undefined
        if (application === null || application === undefined) {
            throw new Error('Required parameter application was null or undefined when calling listLicenses.');
        }
        // verify required parameter 'analysisCode' is not null or undefined
        if (analysisCode === null || analysisCode === undefined) {
            throw new Error('Required parameter analysisCode was null or undefined when calling listLicenses.');
        }
        if (application !== undefined) {
            localVarQueryParameters['application'] = ObjectSerializer.serialize(application, "string");
        }
        if (analysisCode !== undefined) {
            localVarQueryParameters['analysisCode'] = ObjectSerializer.serialize(analysisCode, "string");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "ListLicensesResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List obsolescences in analysis for an application name specified in application parameter and a concrete analysis specified by analysisCode parameter.
     * @summary Get list of obsolescences
     * @param application Application name
     * @param analysisCode Analysis code
     */
    listObsolescences(application, analysisCode) {
        const localVarPath = this.basePath + '/insights/analysis/obsolescence';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'application' is not null or undefined
        if (application === null || application === undefined) {
            throw new Error('Required parameter application was null or undefined when calling listObsolescences.');
        }
        // verify required parameter 'analysisCode' is not null or undefined
        if (analysisCode === null || analysisCode === undefined) {
            throw new Error('Required parameter analysisCode was null or undefined when calling listObsolescences.');
        }
        if (application !== undefined) {
            localVarQueryParameters['application'] = ObjectSerializer.serialize(application, "string");
        }
        if (analysisCode !== undefined) {
            localVarQueryParameters['analysisCode'] = ObjectSerializer.serialize(analysisCode, "string");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "ListObsolescencesResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List security in analysis for an application name specified in application parameter and a concrete analysis specified by analysisCode parameter.
     * @summary Get insight security detail list
     * @param application Application name
     * @param analysisCode Analysis code
     */
    listVulnerabilities(application, analysisCode) {
        const localVarPath = this.basePath + '/insights/analysis/security';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'application' is not null or undefined
        if (application === null || application === undefined) {
            throw new Error('Required parameter application was null or undefined when calling listVulnerabilities.');
        }
        // verify required parameter 'analysisCode' is not null or undefined
        if (analysisCode === null || analysisCode === undefined) {
            throw new Error('Required parameter analysisCode was null or undefined when calling listVulnerabilities.');
        }
        if (application !== undefined) {
            localVarQueryParameters['application'] = ObjectSerializer.serialize(application, "string");
        }
        if (analysisCode !== undefined) {
            localVarQueryParameters['analysisCode'] = ObjectSerializer.serialize(analysisCode, "string");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "ListSecuritiesResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.InsightsApi = InsightsApi;
var LanguagesApiApiKeys;
(function (LanguagesApiApiKeys) {
    LanguagesApiApiKeys[LanguagesApiApiKeys["Cookie"] = 0] = "Cookie";
})(LanguagesApiApiKeys = exports.LanguagesApiApiKeys || (exports.LanguagesApiApiKeys = {}));
class LanguagesApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'Cookie': new ApiKeyAuth('header', 'Cookie'),
            'basicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[LanguagesApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.basicAuth.username = username;
    }
    set password(password) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Obtains a map of languages specifying the language code and the language name
     * @summary Get languages
     */
    getLanguages() {
        const localVarPath = this.basePath + '/languages';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "{ [key: string]: string; }");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.LanguagesApi = LanguagesApi;
var ManagementApiApiKeys;
(function (ManagementApiApiKeys) {
    ManagementApiApiKeys[ManagementApiApiKeys["Cookie"] = 0] = "Cookie";
})(ManagementApiApiKeys = exports.ManagementApiApiKeys || (exports.ManagementApiApiKeys = {}));
class ManagementApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'Cookie': new ApiKeyAuth('header', 'Cookie'),
            'basicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[ManagementApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.basicAuth.username = username;
    }
    set password(password) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Creates a new application in your account.
     * @summary Create application
     * @param body the application to create
     */
    createApplicationNew(body) {
        const localVarPath = this.basePath + '/applications';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createApplicationNew.');
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ApplicationManagementRequest")
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deletes an application of your account.
     * @summary Delete application
     * @param application Application name
     */
    deleteApplication(application) {
        const localVarPath = this.basePath + '/applications';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'application' is not null or undefined
        if (application === null || application === undefined) {
            throw new Error('Required parameter application was null or undefined when calling deleteApplication.');
        }
        if (application !== undefined) {
            localVarQueryParameters['application'] = ObjectSerializer.serialize(application, "string");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get users roles for application. Use 'username' and 'exactUsername' to filter results.
     * @summary Get users roles for application
     * @param application Application name
     * @param username &#39;username&#39; mask to filter results
     * @param exactUsername Indicates if the username must be equals (ignore case). Only apply if username is provided
     */
    getUsersRolesApplication(application, username, exactUsername) {
        const localVarPath = this.basePath + '/applications/{application}/users/roles'
            .replace('{' + 'application' + '}', encodeURIComponent(String(application)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'application' is not null or undefined
        if (application === null || application === undefined) {
            throw new Error('Required parameter application was null or undefined when calling getUsersRolesApplication.');
        }
        if (username !== undefined) {
            localVarQueryParameters['username'] = ObjectSerializer.serialize(username, "string");
        }
        if (exactUsername !== undefined) {
            localVarQueryParameters['exactUsername'] = ObjectSerializer.serialize(exactUsername, "boolean");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "UserApplicationRoleResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Modifies the information of an application in your account.
     * @summary Update application
     * @param body the application to modify
     * @param application Application name
     */
    updateApplication(body, application) {
        const localVarPath = this.basePath + '/applications/{application}'
            .replace('{' + 'application' + '}', encodeURIComponent(String(application)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateApplication.');
        }
        // verify required parameter 'application' is not null or undefined
        if (application === null || application === undefined) {
            throw new Error('Required parameter application was null or undefined when calling updateApplication.');
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ApplicationManagementRequest")
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Modifies the information of an application in your account.
     * @summary Update application with query parameter
     * @param body the application to modify
     */
    updateApplicationWithQueryParameter(body) {
        const localVarPath = this.basePath + '/applications';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateApplicationWithQueryParameter.');
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ApplicationManagementRequest")
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.ManagementApi = ManagementApi;
var PortfolioApiApiKeys;
(function (PortfolioApiApiKeys) {
    PortfolioApiApiKeys[PortfolioApiApiKeys["Cookie"] = 0] = "Cookie";
})(PortfolioApiApiKeys = exports.PortfolioApiApiKeys || (exports.PortfolioApiApiKeys = {}));
class PortfolioApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'Cookie': new ApiKeyAuth('header', 'Cookie'),
            'basicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[PortfolioApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.basicAuth.username = username;
    }
    set password(password) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Creates or update portfolio definitions for an account.
     * @summary Create or update portfolio definitions
     * @param body Portfolio to be saved
     */
    createPortfolioGroups(body) {
        const localVarPath = this.basePath + '/portfolios';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createPortfolioGroups.');
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "PortfolioDefinitionData")
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Check if portfolio and portfolio value exists. This endpoint return an error code 15 if the portfolio name not exists and return true if exists the pair protfolio name and value and false if exists portfolio name but not exists the portfolio value for this portfolio name.
     * @summary Get if portfolio and portfolio value exists
     * @param portfolio Portfolio name
     * @param value Portfolio value
     */
    existsPortfolioValue(portfolio, value) {
        const localVarPath = this.basePath + '/portfolios/{portfolio}/{value}/exists'
            .replace('{' + 'portfolio' + '}', encodeURIComponent(String(portfolio)))
            .replace('{' + 'value' + '}', encodeURIComponent(String(value)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'portfolio' is not null or undefined
        if (portfolio === null || portfolio === undefined) {
            throw new Error('Required parameter portfolio was null or undefined when calling existsPortfolioValue.');
        }
        // verify required parameter 'value' is not null or undefined
        if (value === null || value === undefined) {
            throw new Error('Required parameter value was null or undefined when calling existsPortfolioValue.');
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Obtains the portfolio definitions of an account.
     * @summary Get portfolio definitions
     */
    getPortfolioGroups() {
        const localVarPath = this.basePath + '/portfolios';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<PortfolioDefinitionData>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List all portfolio values asociated to portfolio name. This endpoint return an error code 15 if the portfolio name not exists, in other case, it return the list of portfolio values.
     * @summary Get list of portfolio values by portfolio name
     * @param portfolio Portfolio name
     */
    getPortfolioValuesByName(portfolio) {
        const localVarPath = this.basePath + '/portfolios/{portfolio}/values/list'
            .replace('{' + 'portfolio' + '}', encodeURIComponent(String(portfolio)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'portfolio' is not null or undefined
        if (portfolio === null || portfolio === undefined) {
            throw new Error('Required parameter portfolio was null or undefined when calling getPortfolioValuesByName.');
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<string>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List the users roles for the portfolio. Use 'username', 'exactUsername', 'portfolioValue' and 'exactPortfolioValue' to filter results.
     * @summary Get users roles by portfolio
     * @param portfolio Portfolio name
     * @param username &#39;username&#39; mask to filter results
     * @param exactUsername Indicates if the username must be equals (ignore case). Only apply if username is provided
     * @param portfolioValue &#39;portfolioValue&#39; mask to filter results
     * @param exactPortfolioValue Indicates if the portfolioValue must be equals (ignore case). Only apply if portfolioValue is provided
     */
    getUserRolesPortfolio(portfolio, username, exactUsername, portfolioValue, exactPortfolioValue) {
        const localVarPath = this.basePath + '/portfolios/{portfolio}/users/roles'
            .replace('{' + 'portfolio' + '}', encodeURIComponent(String(portfolio)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'portfolio' is not null or undefined
        if (portfolio === null || portfolio === undefined) {
            throw new Error('Required parameter portfolio was null or undefined when calling getUserRolesPortfolio.');
        }
        if (username !== undefined) {
            localVarQueryParameters['username'] = ObjectSerializer.serialize(username, "string");
        }
        if (exactUsername !== undefined) {
            localVarQueryParameters['exactUsername'] = ObjectSerializer.serialize(exactUsername, "boolean");
        }
        if (portfolioValue !== undefined) {
            localVarQueryParameters['portfolioValue'] = ObjectSerializer.serialize(portfolioValue, "string");
        }
        if (exactPortfolioValue !== undefined) {
            localVarQueryParameters['exactPortfolioValue'] = ObjectSerializer.serialize(exactPortfolioValue, "boolean");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<UserPortfolioRoleData>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.PortfolioApi = PortfolioApi;
var SecurityApiApiKeys;
(function (SecurityApiApiKeys) {
    SecurityApiApiKeys[SecurityApiApiKeys["Cookie"] = 0] = "Cookie";
})(SecurityApiApiKeys = exports.SecurityApiApiKeys || (exports.SecurityApiApiKeys = {}));
class SecurityApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'Cookie': new ApiKeyAuth('header', 'Cookie'),
            'basicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[SecurityApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.basicAuth.username = username;
    }
    set password(password) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Returns grant information on the specified action for the authenticated user. Recognized actions: MUTE_DEFECTS
     * @summary Get permissions for an action
     * @param action Action name
     * @param application Application name
     * @param appId Application identifier
     */
    getAuthorizationForAction(action, application, appId) {
        const localVarPath = this.basePath + '/security/permissions/{action}'
            .replace('{' + 'action' + '}', encodeURIComponent(String(action)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'action' is not null or undefined
        if (action === null || action === undefined) {
            throw new Error('Required parameter action was null or undefined when calling getAuthorizationForAction.');
        }
        if (application !== undefined) {
            localVarQueryParameters['application'] = ObjectSerializer.serialize(application, "string");
        }
        if (appId !== undefined) {
            localVarQueryParameters['appId'] = ObjectSerializer.serialize(appId, "string");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "AuthorizationResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.SecurityApi = SecurityApi;
var UserApiApiKeys;
(function (UserApiApiKeys) {
    UserApiApiKeys[UserApiApiKeys["Cookie"] = 0] = "Cookie";
})(UserApiApiKeys = exports.UserApiApiKeys || (exports.UserApiApiKeys = {}));
class UserApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'Cookie': new ApiKeyAuth('header', 'Cookie'),
            'basicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[UserApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.basicAuth.username = username;
    }
    set password(password) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Creates a new user in your account.
     * @summary Create user
     * @param body the user to create
     */
    createUser(body) {
        const localVarPath = this.basePath + '/users';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createUser.');
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "UserManagementRequest")
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a user of your account.
     * @summary Delete user
     * @param username User name
     */
    deleteUser(username) {
        const localVarPath = this.basePath + '/users/{username}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling deleteUser.');
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List the applications roles for the username. Use 'applicationName' and 'exactApplicationName' to filter results.
     * @summary Get applications roles by user
     * @param username User name
     * @param applicationName &#39;applicationName&#39; mask to filter results
     * @param exactApplicationName Indicates if the applicationName must be equals (ignore case). Only apply if applicationName is provided
     */
    getUserApplicationsRoles(username, applicationName, exactApplicationName) {
        const localVarPath = this.basePath + '/user/{username}/applications/roles'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling getUserApplicationsRoles.');
        }
        if (applicationName !== undefined) {
            localVarQueryParameters['applicationName'] = ObjectSerializer.serialize(applicationName, "string");
        }
        if (exactApplicationName !== undefined) {
            localVarQueryParameters['exactApplicationName'] = ObjectSerializer.serialize(exactApplicationName, "boolean");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<ApplicationRoleData>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List the portfolios roles for the username. Use 'portfolioName', 'exactPortfolioName', 'portfolioValue' and 'exactPortfolioValue' to filter results.
     * @summary Get portfolios roles by user
     * @param username User name
     * @param portfolioName &#39;portfolioName&#39; mask to filter results
     * @param exactPortfolioName Indicates if the portfolioName must be equals (ignore case). Only apply if portfolioName is provided
     * @param portfolioValue &#39;portfolioValue&#39; mask to filter results
     * @param exactPortfolioValue Indicates if the portfolioValue must be equals (ignore case). Only apply if portfolioValue is provided
     */
    getUserPortfoliosRoles(username, portfolioName, exactPortfolioName, portfolioValue, exactPortfolioValue) {
        const localVarPath = this.basePath + '/user/{username}/portfolios/roles'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling getUserPortfoliosRoles.');
        }
        if (portfolioName !== undefined) {
            localVarQueryParameters['portfolioName'] = ObjectSerializer.serialize(portfolioName, "string");
        }
        if (exactPortfolioName !== undefined) {
            localVarQueryParameters['exactPortfolioName'] = ObjectSerializer.serialize(exactPortfolioName, "boolean");
        }
        if (portfolioValue !== undefined) {
            localVarQueryParameters['portfolioValue'] = ObjectSerializer.serialize(portfolioValue, "string");
        }
        if (exactPortfolioValue !== undefined) {
            localVarQueryParameters['exactPortfolioValue'] = ObjectSerializer.serialize(exactPortfolioValue, "boolean");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<PortfolioRoleData>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List the users of your account. Use 'username' and 'emailAddress' (logical AND) to filter results.
     * @summary Get list of users
     * @param username &#39;username&#39; mask to filter results
     * @param exactUsername Indicates if the username must be equals (ignore case). Only apply if username is provided
     * @param emailAddress &#39;emailAddress&#39; mask to filter results
     */
    listUsers(username, exactUsername, emailAddress) {
        const localVarPath = this.basePath + '/users';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (username !== undefined) {
            localVarQueryParameters['username'] = ObjectSerializer.serialize(username, "string");
        }
        if (exactUsername !== undefined) {
            localVarQueryParameters['exactUsername'] = ObjectSerializer.serialize(exactUsername, "boolean");
        }
        if (emailAddress !== undefined) {
            localVarQueryParameters['emailAddress'] = ObjectSerializer.serialize(emailAddress, "string");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<UserDetailResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List the users of your account with their application permissions. Use 'username' and 'emailAddress' and 'applicationName' (logical AND) to filter results.
     * @summary Get list of users and application permissions
     * @param username &#39;username&#39; mask to filter results
     * @param emailAddress &#39;emailAddress&#39; mask to filter results
     * @param applicationName &#39;applicationName&#39; mask to filter results
     * @param exactUsername Indicates if the username must be equals (ignore case). Only apply if username is provided
     * @param exactApplicationName Indicates if the applicationName must be equals (ignore case). Only apply if applicationName is provided
     */
    listUsersWithPermissions(username, emailAddress, applicationName, exactUsername, exactApplicationName) {
        const localVarPath = this.basePath + '/users/applications/permissions';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (username !== undefined) {
            localVarQueryParameters['username'] = ObjectSerializer.serialize(username, "string");
        }
        if (emailAddress !== undefined) {
            localVarQueryParameters['emailAddress'] = ObjectSerializer.serialize(emailAddress, "string");
        }
        if (applicationName !== undefined) {
            localVarQueryParameters['applicationName'] = ObjectSerializer.serialize(applicationName, "string");
        }
        if (exactUsername !== undefined) {
            localVarQueryParameters['exactUsername'] = ObjectSerializer.serialize(exactUsername, "boolean");
        }
        if (exactApplicationName !== undefined) {
            localVarQueryParameters['exactApplicationName'] = ObjectSerializer.serialize(exactApplicationName, "boolean");
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<UserAppsPermissionsResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Modifies the information of an user in your account.
     * @summary Update user
     * @param body the user to update
     * @param username User name
     */
    updateUser(body, username) {
        const localVarPath = this.basePath + '/users/{username}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateUser.');
        }
        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling updateUser.');
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "UserManagementRequest")
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.UserApi = UserApi;
var UserGroupApiApiKeys;
(function (UserGroupApiApiKeys) {
    UserGroupApiApiKeys[UserGroupApiApiKeys["Cookie"] = 0] = "Cookie";
})(UserGroupApiApiKeys = exports.UserGroupApiApiKeys || (exports.UserGroupApiApiKeys = {}));
class UserGroupApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'Cookie': new ApiKeyAuth('header', 'Cookie'),
            'basicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[UserGroupApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.basicAuth.username = username;
    }
    set password(password) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Creates a new user group in your account.
     * @summary Create user group
     * @param body The user group to create
     */
    createUserGroup(body) {
        const localVarPath = this.basePath + '/userGroups';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createUserGroup.');
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "UserGroupRequest")
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deletes a user group of your account.
     * @summary Delete user group
     * @param name User group name
     */
    deleteUserGroup(name) {
        const localVarPath = this.basePath + '/userGroups/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteUserGroup.');
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List the user groups of your account.
     * @summary Get list of user groups
     */
    listUserGroups() {
        const localVarPath = this.basePath + '/userGroups';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<UserGroupResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Modifies the information of an user group in your account.
     * @summary Update user group
     * @param body The user group to modify
     * @param name User group name
     */
    updateUserGroup(body, name) {
        const localVarPath = this.basePath + '/userGroups/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateUserGroup.');
        }
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling updateUserGroup.');
        }
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "UserGroupRequest")
        };
        this.authentications.Cookie.applyToRequest(localVarRequestOptions);
        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.UserGroupApi = UserGroupApi;
//# sourceMappingURL=api.js.map